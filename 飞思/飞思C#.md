# 飞思C#

复习用，直接搬的学习唐老狮时的笔记。

# 2023年5月15日

# 多态vob 知识点

> [C#多态_c#什么是多态_James_probie的博客-CSDN博客](https://blog.csdn.net/Aran_WDX/article/details/80646105#:~:text=表面意思就是“多,现方式即为多态。)

## 知识点一 多态的概念

多态按字面的意思就是“多种状态”，让继承同一父类的子类们 在执行相同方法时有不同的表现（状态）

主要目的：同一父类的对象 执行相同行为（方法）有不同的表现

解决的问题：让同一个对象有唯一行为的特征

一个行为拥有多种表现（一个接口拥有多种功能）

- 静态多态
  - 函数重载
  - 运算符重载
- 动态多态
  - 子类重写父类虚函数

## 知识点三 多态的实现

我们目前已经学过的多态，编译时多态——函数重载，开始就写好的

我们将学习的：运行时多态( vob、抽象函数、接口 )

v: virtual(虚函数)，o: override(重写)，b: base(父类)。

虚函数 可以被子类重写

base的作用：代表父类 可以通过base来保留父类的行为。

```C#
//重写虚函数
public override void Atk()
{
    //base的作用
    //代表父类 可以通过base来保留父类的行为
    base.Atk();
    Console.WriteLine("玩家对象进行攻击");
}
```

> 注意：虚函数不能是私有的

# 函数重载 知识点

## 知识点一 基本概念

在同一语句块(class或者struct)中，函数（方法）名相同或者参数的数量相同，但参数的类型或顺序不同

作用：

1. 命名一组功能相似的函数，减少函数名的数量，避免命名空间的污染
2. 提升程序可读性

注意：

1. 重载和返回值类型无关，只和参数类型，个数，顺序有关
2. 调用时程序会自己根据传入的参数类型判断使用哪一个重载

## 知识点二 实例

注意：

ref，out可以和其他参数作重载，但是两者不可以互相重载

```C#
static float CalcSum(float f, int a)
{
    return f + a;
}

//ref 和 out

// ref和out 可以理解成 他们也是一种变量类型 所以可以用在重载中 但是 ref和out不能同时修饰
static float CalcSum(ref float f, int a)
{
    return f + a;
}
//ref和out不能互相作重载条件，但是可以和其他类型
//错误
//static float CalcSum(out float f, int a)
//{
//    f = 10;
//    return f + a;
//}
```

## 总结

概念：同一个语句块中，函数名相同，参数数量、类型、顺序不同的函数 就称为我们的重载函数。

注意：和返回值无关，ref和out不能互相作为重载条件，变长参数可以。

作用：一般用来处理不同参数的同一类型的逻辑处理。

# 运算符重载 知识点

## 知识点一 基本概念

概念：让自定义类和结构体，能够使用运算符

使用关键字：operator

特点：

1. **一定是一个公共的静态方法**
2. 返回值写在operator前
3. 逻辑处理自定义

作用：让自定义类和结构体对象可以进行运算

注意：

1. 条件运算符需要成对实现
2. 一个符号可以多个重载
3. 不能使用ref和out

## 知识点二 基本语法

```C#
public static 返回类型 operator 运算符(参数列表)
```

## 知识点三 实例

```C#
public static Point operator +(Point p1, Point p2)
{
    Point p = new Point();
    p.x = p1.x + p2.x;
    p.y = p1.y + p2.y;
    return p;
}
```

> 注意：当重载二元运算符时，参数之一必须包含本身类型，并且根据参数顺序决定左操作数和右操作数。

```C#
public static Point operator +(Point p1, int value)
{
    Point p = new Point();
    p.x = p1.x + value;
    p.y = p1.y + value;
    return p;
}

public static Point operator +(int value, Point p1)
{
    Point p = new Point();
    p.x = p1.x + value;
    p.y = p1.y + value;
    return p;
}
```

## 知识点五 可重载和不可重载的运算符

可重载的运算符：

1. 算数运算符：+，-，*，/，%，++，--
2. 逻辑运算符：!（只能重载逻辑非）
3. 位运算符：&，|，~，^，<<，>>
4. 条件运算符：>=，<=；==，!=；<，>；true，false
   1. 返回值一般是bool值 也可以是其它的
   2. **相关符号必须配对实现**
   3. 可以重载true和false，使得一个类型的变量可以作为一个bool值

**不可重载的运算符**：

逻辑与(&&) ，逻辑或(||)，索引符 []，强转运算符 ()

特殊运算符 ：点（.），三目运算符（? :），赋值符号（包括复合赋值运算符）（=，+=，-=....）

> Cpp对比
>
> [C++ 重载运算符和重载函数 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cplusplus/cpp-overloading.html)

# 抽象类和抽象函数 知识点

## 知识点一 抽象类

概念：被抽象关键字abstract修饰的类

特点：

1. 不能被实例化的类
2. 可以包含抽象方法、字段、属性
3. 可以包含非抽象方法
4. 继承抽象类必须重写其抽象方法

```C#
abstract class Thing
{
    //抽象类中 封装的所有知识点都可以在其中书写
    public string name;

    //可以在抽象类中写抽象函数
}
```

### 抽象类的孙子类需要重写抽象函数吗？

不需要，但是仍然可以重写祖宗类的抽象函数。



## 知识点二 抽象函数

又叫 纯虚方法，用 abstract关键字修饰的方法

特点：

1. 只能在抽象类中申明
2. 没有方法体
3. 不能是私有的
4. 继承后必须实现 用override重写

### 抽象方法和虚方法的区别

1. 虚方法是可以由我们子类选择性来实现的
2. 虚方法和抽象方法 都可以被子类无限的 去重写

### 如何选择普通类还是抽象类

不希望被实例化的对象，相对比较抽象的类可以使用抽象类。

父类中的行为不太需要被实现的，只希望子类去定义具体的规则的 可以选择 抽象类然后使用其中的抽象方法来定义规则

作用：整体框架设计时  会使用。

# 二维数组 知识点

## 知识点一 基本概念

二维数组 是使用两个下标(索引)来确定元素的数组

两个下标可以理解成 行标 和 列标

比如矩阵

1 2 3

4 5 6
可以用二维数组 int[2, 3] 表示
好比 两行 三列的数据集合

> 其实是一个n * m的矩阵
>
> 可扩展为多维数组

## 知识点二 二维数组的声明

```C#
//变量类型[,] 二维数组变量名;
int[,] arr; //申明过后 会在后面进行初始化

//变量类型[,] 二维数组变量名 = new 变量类型[行,列];
int[,] arr2 = new int[3, 3];

//变量类型[,] 二维数组变量名 = new 变量类型[行,列]{ {0行内容1, 0行内容2, 0行内容3.......}, {1行内容1, 1行内容2, 1行内容3.......}.... };
int[,] arr3 = new int[3, 3] { { 1, 2, 3 }, 
                             { 4, 5, 6 }, 
                             { 7, 8, 9 } };

//变量类型[,] 二维数组变量名 = new 变量类型[,]{ {0行内容1, 0行内容2, 0行内容3.......}, {1行内容1, 1行内容2, 1行内容3.......}.... };
int[,] arr4 = new int[,] { { 1, 2, 3 },
                          { 4, 5, 6 },
                          { 7, 8, 9 } };

//变量类型[,] 二维数组变量名 = { {0行内容1, 0行内容2, 0行内容3.......}, {1行内容1, 1行内容2, 1行内容3.......}.... };
int[,] arr5 = { { 1, 2, 3 },
               { 4, 5, 6 },
               { 7, 8, 9 } };
```

## 知识点三 二维数组的使用

### 1.二维数组的长度

```C#
Console.WriteLine(array.GetLength(0));//0行数
Console.WriteLine(array.GetLength(1));//1列数
array.Legnth; //2 * 3, 6
```

### 2.获取二维数组中的元素

```C#
// 注意：第一个元素的索引是0 最后一个元素的索引 肯定是长度-1
Console.WriteLine(array[0, 1]);
Console.WriteLine(array[1, 2]);
```

### 3.修改二维数组中的元素

```C#
array[0, 0] = 99;
Console.WriteLine(array[0, 0]);
Console.WriteLine("**********");
```

### 4.遍历二维数组

```C#
for (int i = 0; i < array.GetLength(0); i++)
{
    for (int j = 0; j < array.GetLength(1); j++)
    {
        //i 行 0 1
        //j 列 0 1 2
        Console.WriteLine(array[i, j]);
        //0,0  0,1  0,2
        //1,0  1,1  1,2
    }
}
```

## 总结

1. 概念：同一变量类型的 行列数据集合
2. 一定要掌握的内容：申明，遍历，增删查改
3. 所有的变量类型都可以申明为 二维数组
4. 游戏中一般用来存储 矩阵，再控制台小游戏中可以用二维数组 来表示地图格子

# 交错数组 知识点

## 知识点一 基本概念

交错数组 是 数组的数组，每个维度的数量可以不同

注意：二维数组的每行的列数相同，交错数组每行的列数可能不同

## 知识点二 数组的声明

```C#
//变量类型[][] 交错数组名;
int[][] arr1;

//变量类型[][] 交错数组名 = new 变量类型[行数][];
int[][] arr2 = new int[3][];

//变量类型[][] 交错数组名 = new 变量类型[行数][]{ 一维数组1, 一维数组2,........ };
int[][] arr3 = new int[3][] { new int[] { 1, 2, 3 },
                             new int[] { 1, 2 },
                             new int[] { 1 }};

//变量类型[][] 交错数组名 = new 变量类型[][]{ 一维数组1, 一维数组2,........ };
int[][] arr4 = new int[][] { new int[] { 1, 2, 3 },
                            new int[] { 1, 2 },
                            new int[] { 1 }};

//变量类型[][] 交错数组名 = { 一维数组1, 一维数组2,........ };
int[][] arr5 = { new int[] { 1, 2, 3 },
                new int[] { 1, 2 },
                new int[] { 1 }};
```

## 知识点三 数组的使用

### 1.数组的长度

```C#
//行
Console.WriteLine(array.GetLength(0));
//得到某一行的列数
Console.WriteLine(array[i].Length);
```

### 2.获取交错数组中的元素

```C#
// 注意：不要越界
Console.WriteLine(array[0][1]);
```

### 3.修改交错数组中的元素

```C#
array[0][1] = 99;
Console.WriteLine(array[0][1]);
```

### 4.遍历交错数组

```C#
for (int i = 0; i < array.GetLength(0); i++)
{
    for (int j = 0; j < array[i].Length; j++)
    {
        Console.Write(array[i][j] + " ");
    }
    Console.WriteLine();
}
```

## 总结

1. 概念：交错数组 可以存储同一类型的m行不确定列的数据
1. 一定要掌握的内容：声明、遍历、增删查改
1. 所有的变量类型都可以申明为 交错数组
1. 一般交错数组很少使用 了解即可

# ref和out 知识点

## 知识点一 学习ref和out的原因

它们可以解决 在函数内部改变外部传入的内容 里面变了 外面也要变

> 其实就是传递引用

## 知识点二 ref和out的使用

```C#
//函数参数的修饰符
//当传入的值类型参数在内部修改时 或者引用类型参数在内部重新申明时
//外部的值会发生变化

//ref
static void ChangeValueRef(ref int value)
{
    //out传入的变量必须在内部赋值 ref不用
    value = 3;
}

static void ChangeArrayRef(ref int[] arr )
{
    arr = new int[] { 100, 200, 300 };
}

//out
static void ChangeValueOut(out int value)
{
    //out传入的变量必须在内部赋值 ref不用
    value = 99;
}

static void ChangeArrayOut(out int[] arr)
{
    arr = new int[] { 999, 888, 777 };
}

static void Main(string[] args)
{
    Console.WriteLine("ref和out");
    int a = 1;
    ChangeValueRef(ref a);
    ChangeValueOut(out a);
}

```

## 知识点三 ref和out的区别

相同点：

1. 都是为了引用传递
2. 实参必须都填写对应的修饰符

不同点：

1. ref传入的变量必须初始化，out不用
2. out传入的变量必须在内部赋值，ref不用

ref传入的变量必须初始化 但是在内部 可改可不改

out传入的变量不用初始化 但是在内部 必须修改该值（必须赋值）

# C#课件

## 类语法

类：class {}  

### 类语法

- 访问权限 指定对类以及成员的访问规则
- 类默认访问权限：internal
- 成员默认访问权限：private
- public:公有的，能在任意程序集中的类中和类外访问
- protected:受保护的，只能在任意程序集中的类中和子类中访问
- private:私有的，只能在任意程序集中的类中访问
- internal:只能在当前程序集中的类中和类外访问
- protected internal:protected or internal:既可以在任意程序集的类中和子类中访问，也可以在当前程序集类中和类外访问
- 访问类的成员变量时，使用点（.）运算符
- 成员变量未赋值时，默认为0,类类型变量为空

### 静态变量

- 静态变量访问 类名.变量名  类名.函数名
- 存储在静态成员中的数据只有在应用程序退出时才会从内存释放
- 静态成员不能通过对象访问，只能通过类名访问
- 静态成员在内存中只存储一份

### 其他

- 程序集：一个项目，类型元数据，程序集元数据，IL代码，资源
- 元数据：一般指的描述自身的数据
- 程序集元数据：包含程序集的版本信息，安全信息，签名等
- 类型元数据：记录程序集引用了哪些类，用户自定义了哪些类，字段，数据类型等一系列信息
- IL代码：MSIL，C#-编译成IL代码，保存到程序集，通过CLR加载后，通过JIT调用BCL(基础类库)编译成机器码让CPU运行
- 资源：图片，声音，视频等

## 值类型和引用类型

- 值类型：变量直接存储数据 int float double char bool struct byte short 值类型变量声明后，不管是否已经赋值，编译器都会为其分配内存
- 引用类型：变量持有的是数据的引用，具体的数据存储在堆区，class string interface  delegate  当声明一个类时，在栈区中分配一小片内存用于存储地址，当使用new创建对象时，分配堆区的内存，并且将堆区的地址保存到栈区分配的这一片内存上

### 值类型与引用类型的区别？

1. 值类型的数据是存储在栈区，引用类型的数据是存储在堆区的，而内存中存储堆区对象的地址
2. 值类型存取速度快，引用类型存取速度慢
3. 值类型存放具体的数据，引用类型表示指向存储在堆区中的数据的地址
4. 值类型继承自System.ValueType,引用类型继承自System.Object
5. 栈区的内存是自动释放的，而堆区的内存是由GC回收

## 封装

## 属性与字段

属性是类，结构，接口的命名成员，类或者结构中的成员变量和方法称为域，属性是域的扩展

属性对私有变量的访问的优点：

1. 可以对赋值进行合法性检查
2. 增强封装性

## 继承

一个类是可以派生出多个类，一个类只有一个父类  单继承类，多继承接口

注意：在静态方法中base关键字是错误的

## 多态

多态：同一个行为具有多个不同的表现形式 

静态多态：编译，函数重载，运算符重载

函数重载：函数名相同，参数个数不同，顺序不同，类型不同，不能重载只有返回值类型不同的函数

运算符重载 具有特殊名称的函数 operator

运算符：

```C#
+ - * / %  +（正号）-（负号） ! ~ ++ -- == >= <= > < != 可以被重载
+= *= /= %= -= ?: new is sizeof typeof . = 不能被重载
```

动态多态：运行 虚函数 抽象

## for与foreach

foreach语法简洁，for循环给初值，步长，末值，forach是不需要的，自动遍历集合中的所有值
不需要去关心数组的索引是从哪里开始，不会越界，不能指定位置进行遍历
效率上比for要高，foreach遍历的速度比for快
多维数组的遍历只需要一行代码

缺点：foreach循环时会释放使用完的资源，从而会导致额外的GC开销
foreach是只读循环，无法对集合进行修改
集合中的每一项必须与其他项类型相同

> [C# 为什么循环使用Foreach 效率要高 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/555398601)
>
> [C#效率优化（3）-- 使用foreach时避免装箱 - Minotauros - 博客园 (cnblogs.com)](https://www.cnblogs.com/minotauros/p/10577149.html)

## out与ref

out与ref都是用来修饰参数的

相同点：

1. 都是址传递，执行方法后，原来的值会改变
2. 参数在传递的时候，都是采用变量，并且传递时要加上对应的修饰

不同点：

1. 退出方法时，所有被out修饰的参数必须要赋值，而ref不需要
2. 使用ref时，传入的参数必须要初始化，而使用out时，是不需要初始化的

## base关键字

1. 调用基类中已被其他重写的方法，也可以调用其他方法
2. 调用基类中的构造函数
3. 在静态函数中不能使用base关键字

## override关键字

- 用于重写基类中的虚方法，抽象方法，在派生类中提供一个新的方法，重写是在子类中重写父类的方法
- new 分配堆区的内存，调用构造函数进行初始化
- 在子类中使用new关键字定义的与父类中同名的函数，叫覆盖，覆盖是不会改变父类方法的功能

## new与override

1. 不管是重写还是覆盖都不会影响父类自身的功能
2. 当用子类创建父类时 ，比如A c=new B() 重写：会调用子类的功能，覆盖:仍调用父类的功能
3. 虚函数，实方法都可以被覆盖，抽象方法，接口不可以
4. 抽象函数，接口，虚函数都可以被重写，实方法不可以

## 接口

1. 接口中只包含成员的声明，成员的定义是派生类的责任,继承了接口，那么就必须实现该接口中的所有成员，且方法名与接口定义的方法名一致
2. 接口默认访问权限public,且不允许显式声明
3. 接口是不能实例化的
4. 接口是不能被直接实例化的，但是可以在派生类中实例化

## 接口与抽象类的区别？

相同点：

1. 都可以被继承
2. 都不能实例化
3. 自身都不提供具体的实现，派生类中必须实现未实现的方法

不同点：

1. 单继承类，多继承接口
2. 抽象类可以包含字段，属性，方法，接口只能定义属性，事件，方法，不能包含字段
3. 抽象类的实现具体方法默认是虚的，实现接口的类中的接口方法默认是非虚的
4. 接口具备专一性

## 字符串

字符串    引用类型  System.String
字符串变量  StringBuilder System.Text.StringBuilder

1. 少量的字符串，且字符串不经常发生变化时，优先采用string
2. stringbuilder运行速度比string快

## 静态类

1. 静态类中，只能包含静态成员(字段，属性，方法),常量
2. 静态构造函数中不能有参数和访问修饰符
3. 静态构造函数可以存在于普通类或静态类中
4. 静态构造会在第一次调用静态成员时调用
5. 静态类不能被继承
6. 静态类中的所有成员必须是静态的，而普通类中可以有静态成员

## 抽象类

1. 关键字 abstract
2. 抽象类中抽象方法只能声明不能实现,但是在子类中必须全部实现
3. 抽象类是可以包含非抽象方法，但是抽象方法只能写在抽象类中
4. 抽象方法不能被private修饰
5. 抽象类是不能被直接实例化的，但是可以在派生类中实例化

## 密封类

1. 密封类不能作为基类被继承，但是他可以继承别的类或接口
2. 在密封类中不能声明受保护的成员或虚成员，因为受保护的成员只能从派生类中进行访问，而虚成员只能在派生类中进行重写
3. 密封类不能声明为抽象的，即sealed不能与abstract同时使用
4. 密封类除了不能被继承外，与普通类用法一致，而密封方法并不是每个方法都可以被声明为密封，只能用于基类中的虚方法才可以被密封，所以sealed与override是同时出现的

## 委托和匿名函数

委托：函数指针，是存有对某个方法的引用  引用类型  通常用于回调，事件 System.Delegate
委托声明决定了可由该委托引用的方法，委托可指向一个与其具有相同标签的方法
关键字 delegate

多播委托
委托对象可使用“+”运算符进行合并，一个合并委托调用它所合并的多个委托，只有相同类型的委托才能被合并，“-”运算符可用于从合并的委托中移除委托

匿名函数
提供了一种传递代码块作为委托参数的技术，匿名函数是没有名字的，只有主体方法，在匿名函数中不需要指定返回值类型，系统会在主体内通过return语句进行推断
匿名函数即没有名字的方法，关键字delegate
匿名函数只能将方法赋值给委托，通过委托去调用该函数，匿名函数本质上还是一个方法，只是没有名字而已，任何使用委托的地方都可以用匿名函数赋值

```C#
Func<int, int, string> func = delegate(int a, int b) {
	return "Panzi";
};
```

## 事件

事件，事件是基于委托的，为委托提供了一个发布/订阅机制，可以说事件是一种具有特殊签名的委托
event
事件是委托的特殊实现，事件是建立在对委托语言支持之上的，委托是一种类型，事件是委托的一个实例

## C数据结构

数据结构
数组：存储相同数据类型的元素，固定大小，顺序集合，内存都是连续的
数据类型[] 数组名 引用类型
当创建数组时，C#会根据数据类型隐式的初始化每个数组元素默认值  比如是int类型，那么所有元素默认为0
Array是所有数组的基类

array
ArrayList 在这个命名空间下System.Collections;
动态数组，允许在列表中进行动态内存分配，自动扩容
是因为所有的数据都当做了object进行处理，装箱与拆箱
装箱：值类型转换到引用类型
拆箱：引用类型转换到值类型
一定是被装过箱的对象才能被拆箱
装箱的具体过程：
1.分配堆区的内存（大小为值类型的大小+一个指针和索引）
2.将值类型的数据拷贝到新分配的内存中
3.返回堆区所分配的对象的地址
拆箱的具体过程
1.首先在堆区获取到属于值类型数据的地址
2.将地址中的数据拷贝到值类型实例中
从原理层面，装箱是需要去开辟新的内存空间的，所以会有时间损耗，效率会受到影响
类型不安全
List
和ArrayList基本一致，唯一区别：强类型
LinkedList
链表 双向链表 LinkedListNode:节点

数组：在声明时必须指定数组的大小，过长会造成内存浪费，过短内存溢出，插入数据比较麻烦
ArrayList：可以存储任意数据类型，但是因为存在装箱与拆箱会造成性能损耗，以及类型不安全
List：不需要声明大小，会自动扩容，避免了装箱与拆箱
LinkedList:链表，遍历比较慢，插入，删除快

队列
栈
哈希表
字典

字典与哈希表区别
相同点：
1.都是键值对形式，键是唯一的，值不是唯一的，都是无序的键值对
2.存储的个数不受限制
3.都是通过foreach遍历
不同点：
1.键与值的类型不一致，字典是必须要指定类型，哈希表是object类型
2.命名空间不一致 哈希表System.Collections   字典System.Collections.Generic
3.限制类型不一致  字典存储时限定了类型，哈希表是当做object进行存储
4.效率上，字典的效率高

作业：实现ArrayList的任意数据类型的排序

