# 飞思夏令营

# C/C++

# 第一天（2022年6月23日，第一周）

## 1.Visual Studio基本使用

解决方案：可以包含多个项目，每次只能执行一个项目(执行哪个项目就设置哪个项目为启动项目（右键）)

每个项目：有且仅有一个main函数

基本步骤：建立项目->编写代码->编译（生成解决方案（F8/ctrl+shift+b））->运行（不调试，出现逻辑错误或者内存错误）->调试

## 2.C和C++基本区别

C是面向过程的，C++是面向对象的

## 3.引用头文件

```cpp
#include <stdio.h> //<> 从系统目录下寻找头文件
#include "stdio.h" //"" 先从当前目录下搜索该文件，找不到再从系统目录下搜索
```

一般情况下，系统目录文件使用<>，自定义/本地文件使用""

查看系统目录：项目->属性->VC++目录->包含目录

可在此面板下将本地文件包含为系统文件，然后可在代码中直接使用<>包含

当前文件目录：就是本文件所处磁盘目录

引用上一层目录：

```cpp
#include "../libname/"
```

## 4.常量和变量

常量：在程序中不可以改变的量，一般以值的形式存在，如：整数，字符，宏定义。

变量：在程序中可以边的量，需要先定义，再使用。

C++是编译型语言，变量需要先定义，再使用

lua是解释型语言，变量可以直接使用

变量定义：类型 变量名

变量名必须是合法标识符

1.字母、数字、下划线

2.开头只能是字母或下划线

3.不能是关键字

### 注意事项：

1.区分大小写

2.名字不宜过长

3.顾名思义

4.命名法则

正式命名法（每个英文单词首字母大写，大驼峰）

驼峰命名法：

（1）大驼峰（帕斯卡命名法）：每个单词首字母都大写，常用于类名、函数名、属性、命名空间

（2）小驼峰命名法：除了第一个单词，其余首字母全大写，常用于变量

匈牙利命名法：

基本原则：变量名 = 属性 + 类型 + 对象描述

属性：g\_（全局变量），m\_(成员变量)，s\_（静态变量）,C(类或者结构体)

> [匈牙利命名法则_haiross的博客-CSDN博客_匈牙利命名法](https://blog.csdn.net/haiross/article/details/45147993)

下划线命名法：单词全部小写，每个单词间下划线分隔

## 5.基本数据类型

整型、字符型、布尔型、枚举类型

整型常量表示方法：二进制、八进制、十进制、十六进制

八进制：以0开头，每一位上的数0-7

十六进制：以0x开头，每一位上的数0-9，a-f

### （1）进制转换

十进制->n进制：该数除以n求余数，商继续除以n求余数，直到为零

n进制->十进制:从右往左，每一位上的数乘以n的m次方之和，m从0开始，一次加一

二进制->八进制：从右向左，每三位二进制数为一个八进制数

八进制->二进制：从右向左，每一位八进制数为三位二进制数

二进制->十六进制：从右向左，每四位二进制数为一个八进制数，超过十为a-f

十六进制->二进制：从右向左，每一位八进制数为四位二进制数，超过十为a-f

例如：

0xab

10101011

### （2）整型分类

整型分类：short，int，long，long long

类型修饰符：singed有符号，unsigned无符号

有符号最高位0为正，1为负

int16_t,int32_t,int64_t

uint16_t,uint32_t,uint64_t

计算机存储基本单位为一个字节（8位二进制数）

获取类型所占字节数：sizeof(参数)

### （3）求数据类型表示范围

求short型表示范围：

short：2个字节，16位，-32768 ~ 32767

最大数：01111111 11111111 = 10000000 00000000 - 1 = 2^15 - 1 = 32767

最小数：10000000 00000000 = -2^15 = -32768

usigned short：2个字节，16位，0 ~ 65535

最大数：11111111 11111111 = 65535

最小数：00000000 00000000 = 0

### （4）数据溢出

当变量的值超出了数据类型的表示范围即为数据溢出

计算机处理：自动调整到数据类型的表示范围

大于最大值，则数值 = 当前数值 - 2^(sizeof(类型))

小于最小值，则数值 = 当前数值 + 2^(sizeof(类型))

### （5）整型变量的定义

1. 命名规范
2. 如何选择整型
   1. 节约内存
   2. 避免数据溢出
   3. 有无符号

## 6.C++输入输出

cout可以使用流操纵算子来进行格式化输出

## 代码

```cpp
/*
	解决方案：可以包含多个项目，每次只能执行一个项目(执行哪个项目就设置哪个项目为启动项目（右键）)
	每个项目：有且仅有一个main函数
	基本步骤：建立项目->编写代码->编译（生成解决方案（F8/ctrl+shift+b））->运行（不调试，出现逻辑错误或者内存错误）->调试
*/
//引用头文件：C语言标准输入输出库
#include<stdio.h>
#include<iostream> //C++标准输入输出流

//#include "stdio.h"

using namespace std;	//引用命名空间

//主函数或入口函数
int main() 
{
    //求数据类型所占字节数：sizeof();
    cout << sizeof(int) << endl;
	cout << "Game start" << endl;
    int num = 0;
    cin >> num;
    cout << setbase(10) << showbase << num << endl; //以十进制输出
    cout << oct << showbase << num << endl; //以八进制输出
    cout << hex << showbase << num << endl;	//以十六进制输出
    return 0;
}
```

## 作业

1. 什么是匈牙利命名法？

   属性+类型+对象描述

2. C语言printf输出整数时，格式符没有一一对应，计算机如何处理？

   没有一一对应时，多出来的格式符会输出未知数字

   ```cpp
   #include <iostream>
   
   using namespace std;
   
   int main() {
   	int num1 = 1;
   	int num2 = 2;
   	printf("%d, %d, %d", num1, num2);
   	return 0;
   }
   /*
   	output:1, 2, 未知数字
   */
   ```

3. 不同整型变量的输入和输出（以C语言和C++分别输入和输出）

   c语言用scanf输入，C++用cin输入

   c语言用printf输出，C++用cout输出

   C++中cout格式化输出

   > [c.biancheng.net](http://c.biancheng.net/view/275.html) C++格式化输出

# 第二天（2022年6月24日）

## 1.字符型

char型，1个字节，有符号-128\~127，无符号0\~255

字符常量：'a','0',转义字符

常用转义：'\\t'（tab），'\\n'(换行)，'\\数字'（最多三位八进制数），'\\x数字'（最多两位十六进制数）

注意：转义十六进制时，如果数字超过两位的数依然是十六进制数，会报错超出范围的错误

所以，以下代码是正确的

```cpp
cout << (int)'\x00000010' << endl;
/* output 16 */
```

字符串常量："abc","123"，默认以'\\0'结尾，即会多出一个字节来存储'\\0'

```cpp
cout << sizeof("abcd") << endl;
/* output 5 */
cout << sizeof("abcd\0123") << endl;
/* output 7 */
```

### 字符型存储实质

字符型变量存储的实际上是ASCII码值

所以以下代码输出为48

```cpp
cout << int('0') << endl;
/* output 48 */
```

常用ASCII码值

'A':65

'a':97

' ':32(空格)

'0':48

### 字符和整型之间转换

```cpp
int num = '0' - 48
cout << num << endl;
/* output 0 */
```

## 2.布尔型

布尔型：bool，0\~1

布尔型常量：true和false

C++中一切非零的数都为真

## 3.浮点型

浮点型：float（4字节）、double（8字节）、long double（8字节）

浮点型常量表示方法

1. 小数形式：3.14
2. 指数形式：3.2e-2(计算机存储的方式)

C语言输出%f，最多保存小数6位，%e以科学计数法显示

## 4.类型计算原则

总原则：

### 1.整型提升

**bool，char，unsigned，char，short，unsigned/short int**

**计算时，转换为int或者unsigned int（有一个操作数为unsigned int 时）。**

### 2.计算结果的类型以精度高的类型为准

所以有以下运行结果

```cpp
#include <iostream>
#include <iomanip>

using namespace std;

int main() {
	unsigned int uint = 10;
	short sint = -20;
	cout << sizeof('a' + true) << endl;	//提升为int
	cout << uint + sint << endl; //最终结果为-10，但是是unsigned int,
	//2^32 - 10
	return 0;
}
/*
	output
	4
	4294967286
*/
```

## 5.算术运算符

运算符：运算法则、优先级、结合性

算术运算符：+，-，*，/，%

1. 运算符'%'，两边只能为整数，不能为浮点数
2. 运算符'%'，结果的符号与左操作数的符号相同
3. 结合性：从左往右，先乘除后加减

### 拆分数字

```cpp
#include <iostream>
#include <iomanip>

using namespace std;

int main() {
	long long num = 12345;
	cout << num << "个位上的数是：" << num / 1 % 10 << endl;
	cout << num << "十位上的数是：" << num / 10 % 10 << endl;
	cout << num << "百位上的数是：" << num / 100 % 10 << endl;
	cout << num << "千位上的数是：" << num / 1000 % 10 << endl;
	cout << num << "万位上的数是：" << num / 10000 % 10 << endl;
	return 0;
}
/*
	output
	12345个位上的数是：5
	12345十位上的数是：4
	12345百位上的数是：3
	12345千位上的数是：2
	12345万位上的数是：1
*/
```

### 交换数字

```cpp
#include <iostream>
#include <iomanip>

using namespace std;

int main() {
	long long numA = 10;
	long long numB = 20;
	//通过第三个变量进行交换
	long long temp = numA;
	numA = numB;
	numB = temp;
	cout << numA << " " << numB << endl;
	//不通过第三个变量进行交换(可能溢出）
	numA = numA + numB;
	numB = numA - numB;
	numA = numA - numB;
	cout << numA << " " << numB << endl;
	return 0;
}
/*
	output
	20 10
	10 20
*/
```

## 6.自增自减运算符

自增自减运算符：++，--

使用此运算符，本身必须为变量

前缀++为先加再用，后缀++为先用再加

前缀和后缀的区别：

1. 运算法则不同。
2. 优先级不同：前缀大于后缀
3. 效率不同：前缀大于后缀

```cpp
#include <iostream>
#include <iomanip>

using namespace std;

int main() {
	long long numA = 10;
	long long numB = 0;
	//(numA + numB)++;	//error：表达式必须是可修改的左值
	numB = numA++;	//后缀++，先用再加
	cout << "后缀自增：" << numB << endl;
	numB = ++numA;
	cout << "前缀自增：" << numB << endl;
	return 0;
}
/*
	output
	后缀自增：10
	前缀自增：12
*/
```

## 7.赋值运算符

赋值/复合赋值运算符：=，+=，-=，*=......

1. 左操作数必须为变量
2. 结合性从右往左
3. 优先级为倒数第二，最后一个为逗号运算符

```cpp
#include <iostream>
#include <iomanip>

using namespace std;

int main() {
	long long a = 2;
	long long b = -2;
	cout << a << " " << b << endl;
	b += a++;
	cout << a << " " << b << endl;
	b += ++a;
	cout << a << " " << b << endl;
	++b += a++;
	cout << a << " " << b << endl;
	return 0;
}
/*
	output
	a = 2 b = -2
	a = 3 b = 0
	a = 4 b = 4
	a = 5 b = 9
*/
```

## 8.逗号运算符

逗号运算符：,

1. 优先级最低
2. 结合性从左往右
3. 逗号表达式的值为最后一个表达式的值

## 作业

1.字符型、布尔型、浮点型变量的输入和输出（C/C++）

```cpp
#include <iostream>

using namespace std;

int main() {
	char buf = 'a';
	double f = 3.1415926;
	bool flag = true;
	printf("%c %f %d\n", buf, f, flag);
	cout << buf << " " << f << " " << flag << endl;
	return 0;
}
/*
	output
	a 3.141593 1
	a 3.14159 1	
*/
```

2.三种浮点型的精度

```cpp
#include <iostream>
#include <iomanip>

using namespace std;

int main() {
	float fnum = 12.3456789012345;
	double dnum = 12.3456789012345;
	long double ldnum = 12.3456789012345;
	printf("%f, %lf, %lf\n", fnum, dnum, ldnum);
	cout << setprecision(15);	//设置输出精度为15
	cout << fnum << " " << dnum << " " << ldnum << endl;
	return 0;
}
/*
	output
	12.345679, 12.345679, 12.345679
	12.3456792831421 12.3456789012345 12.3456789012345	
*/
```

由于float的精度为6\~7位，因此这里只输出了7位有效小数数字（包含"."），而从第7位往后则均不正确。而double的有效位数是15\~16位，对于精度要求高的时候，尽量用double，以免出错。

了解部分：

1.小数部分如何转化为二进制

**(1)整数部分的转换：**采用”除2取余法“；
**(2)小数部分的转换：**采用”乘2取整法“；

2.浮点数是如何存储的

分段存储，IEE754

> [C++基础---浮点型_Cainv89的博客-CSDN博客_c++浮点型](https://blog.csdn.net/cainv89/article/details/47115519)

# 第三-四天（2022年6月25-26日）

周末

# 第五天（2022年6月27日，第二周）

## 1.运算符优先级

范围解析 > 单目 > 双目 (算术 > 左移右移 > 关系 > 按位 > 逻辑 > 条件(三目) > 赋值 > throw > 逗号)

> [C++运算符优先级表[中文版\]_C语言中文网 (biancheng.net)](http://c.biancheng.net/cpp/biancheng/view/2079.html)

## 2.关系运算符

\>,\<, >=, <=, ==

运算符结果类型为bool型

## 3.逻辑运算符

\!,&&,||

运算结果为bool型

逻辑非：！，真则假，假则真

逻辑与：&&，同真为真，有假即假，左结合，若左表达式为假，右表达式不参与计算

逻辑或：||，同假为假，有真为真，左结合，若左表达式为真，右表达式不参与计算

## 4.条件运算符

?:

可以将简单的if语句转换为条件运算符

条件运算符可以嵌套

**注意：三目运算符的结合性是从右到左的！**

```cpp
int a, b, c;
cin >> a >> b >> c;
int maxNum = a > b ? (a > c ? a : c) : (b > c ? b : c);
cout << maxNum << endl;
```

## 5.原码、反码、补码

**计算机以二进制补码的形式参与运算与存储，以原码的形式输出和显示**

原码：最高位表示符号位，其他位表示大小

反码：正数：原码就是反码；负数：符号位不变，其它按位取反

补码：正数补码与原码相同；负数：反码+1

补码的补码就是原码

## 6.位运算符

### （1） 按位非：“~”

按位取反（原码取反，但是补码存储）

```cpp
int n = 10;
/* 
	10的原码:0 0000000 00000000 00000000 00001010
	10的反码:0 0000000 00000000 00000000 00001010
	10的补码:0 0000000 00000000 00000000 00001010
	~        1 1111111 11111111 11111111 11110101 补码(看成原码求补码)
			 1 0000000 00000000 00000000 00001010 反码
			 1 0000000 00000000 00000000 00001011 原码(补码的补码就是原码)
											-11
	~n=-(n+1)
	所以有 ~n = -11
*/
```

**公式：~n = -(n + 1)**，加一取负

所以有

```cpp
	int x = 160;
	x = ~x;
	cout << x << endl;
/*
	x = ~x = -(x + 1);
	output
	-161
*/
```

### （2） 按位左移：“<<”

低位补零

n << m;

就是在没有发生溢出的情况下，n = n *2^m;

只要有赋值，就需要考虑溢出，所以有以下输出

```cpp
char c = 10;
c = c << 4;
cout << (int)c << endl; //160 - 256 = -96
/*
	output -96
*/
```

### （3）按位右移：“>>”

**正数高位补零，负数高位补1（补符号位）**

n >> m;

1. 如果n为正数，n = n / 2\^m
2. **如果n为负数，能整除2\^m， 则n = n / 2\^m；不能整除2\^m，则n = n / 2\^m - 1**

所以有以下输出

```cpp
	cout << (10 >> 2) << endl;
	cout << (-10 >> 1) << endl;
	cout << (-10 >> 2) << endl;
	/*
		output:
		2
		-5
		-3
	*/
```

### （4）按位与：“&”

同1为1，有0即0

### （5）按位异或：“^”

同则为0，异则为1

### （6）按位或：“|”

同0为0，否则为1

### （7）例子

1. 判断一个整数是否为2的n次幂?

   ```cpp
   x & (x - 1) ? "No" : "Yes";
   ```

2. 判断一个整数是正数还是负数，不使用if

   数的最高位按位与1

3. 判断一个数是奇数还是偶数，不使用%

   ```cpp
   if (x & 1) {
   	cout << "奇数" << endl;
   } 
   else {
   	cout << "偶数" << endl;
   }
   ```

3. 不经过第三方变量交换两个整型变量的值（没有溢出）

   使用按位异或

   ```cpp
   y = x ^ y;
   x = x ^ y;
   y = x ^ y;
   ```

4. 计算例子

   ```cpp
   #include <iostream>
   #include <iomanip>
   
   using namespace std;
   
   int main() {
   	char a, b;
   	a = 0xab;
   	//10101011
   	b = ~a >> 4 + 1;
   	cout << int(b) << endl;
   	/*
   		11111111 11111111 11111111 10101011 //a
   		00000000 00000000 00000000 01010100 //~a
   		00000000 00000000 00000000 00000010 //~a >> 5
   		output 2
   	*/
   }
   ```

## 作业

1. 从键盘中输入一个字符，如果是大写字母转换为小写字母，如果是小写字母转换为大写字母，其他字符不变(使用条件运算符)

   ```cpp
   #include <iostream>
   #include <iomanip>
   
   using namespace std;
   
   int main() {
   	cout << "请输入一个字母：";
   	char buf = 0;
   	cin >> buf;
   	buf = (buf >= 'a' && buf <= 'z') ? (buf - 32) : (buf >= 'A' && buf <= 'B') ? (buf + 32) : buf;
   	if (buf) {
   		cout << buf << endl;
   	}
   	else {
   		cout << "不是一个字母" << endl;
   	}
   }
   ```

# 第六天（2022年6月28日）

## 1.语句分类

简单语句和复合语句

简单语句：大多一行，以";"结尾

复合语句：大多多行，在"{}"内

复合语句：顺序语句、分支语句、循环语句、转移语句

## 2.条件语句

### （1）执行流程

从上往下一次判断表达式值，哪个表达式的值为真，执行哪一个语句块

```cpp
if (表达式) 
{
	语句块一;
} 
else if (表达式)
{
	语句块二;	
}
else if (表达式) 
{
    语句块三;
}
......
```

### （2）类型与0的关系

整型常量与0的关系

常量作为表达式左值

```cpp
int n = 10;
if (0 == n) //常量作为运算符的左值
{
	cout << n << "等于0" << endl;
}
```

布尔型与0的关系

```cpp
bool b = false;
if (!b)
{
	cout << b << "等于0" << endl;
}
```

float与0的关系

**float 一般不参与等值判断，只参与范围判断**

```cpp
float f = 0.01;
if (f >= -0.000001 && f <= 0.000001) 
{
    cout << f << "等于0" << endl;
}
```

### （3）就近原则

if与else一般匹配最近的

### （4）语法规范

1. 常量一般做左值
2. 多条件判断时，限定条件较多的先行判断
3. float一般不参与等值判断，只参与范围判断
4. 应当尽量避免多次判断，优化效率

## 3.switch语句

switch语句

```cpp
switch (表达式) 
{
	case 常量表达式: 语句;break;
	case 常量表达式: 语句;break;
	case 常量表达式: 语句;break;
	......
	case 常量表达式: 语句;break;
	case 常量表达式: 语句;break;
	default: 语句;
}
```

**注意：表达式的值必须为一个除了float的基本数据类型的值**

### （1）执行流程

根据表达式的值，找到对应的case依次往下执行，直到出现break

### （2）语法规范

一般来说，每一个case后都需搭配一个break

## 4.循环语句

循环语句

```cpp
while (表达式) 
{
    语句块;
}

do 
{
    语句块
}while(表达式)
    
for (初值表达式; 条件表达式; 迭代表达式)
{
    语句块
}
```

注意：

1. do while至少执行一次
2. for循环表达式可以省略
3. **循环可以嵌套**
4. continue：跳过本次的循环体语句
5. break：跳出整个循环

## 5.转移语句

goto，一般不使用

## 6.随机函数：rand()

**产生随机数需要设置随机种子，否则将不随机**

```cpp
#include<iostream>
#include<time.h>

using namespace std;

int main() 
{
	srand(time(0));	//设置随机种子
	int num = rand();
	cout << num << endl;
}
```

**通过"%"控制随机数范围**

```cpp
#include<iostream>
#include<time.h>

using namespace std;

int main() 
{
	srand(time(0));	//设置随机种子
	//产生[20, 30]区间的数
    //公式：int num = rand() % (max - min + 1) + 20;
    int num = rand() % (30 - 20 + 1) + 20;
    cout << num << endl;
}
```

# 第七天（2022年6月29日）

做题

# 第八天（2022年6月30日）

## 1.数组

### （1）数组定义

数组是相同数据类型的集合

语法：数据类型 数组名[数组元素个数];

注意：

**数组元素个数只能为常量或常量表达式**

**一维数组不指定元素个数时，必须初始化**

```cpp
//定义一个拥有100个元素的int型数组
int nums[100];	
//一维数组可以不指定数组宽度，但是需要初始化
int array[] = {0, 1, 2, 3};
```

### （2）求数组所占内存字节大小

使用sizeof

```cpp
int nums[100] = {0};
cout << sizeof(num) << endl;
/* 	output
	400
*/
```

### （3）数组内存是连续的

数组存储时是连续的

注意：int占4个字节

```cpp
	int nums[100];
	for (int i = 0; i < 5; ++i) {
		cout << hex << &nums[i] << endl;
	}
/* output
0075F5CC
0075F5D0
0075F5D4
0075F5D8
0075F5DC
*/
```

### （4）通过下标访问数组元素

语法：数组名[下标]

数组下标是从0开始的，到数组元素个数减一

注意：**数组下标是一个整型表达式**

```cpp
cout << nums[0] << endl;
```

### （5）下标越界

当下标超出数组元素范围时，系统会报内存访问错误，即下标越界

```cpp
int nums[10] = {0};
cout << nums[10] << endl; 	//error! 数组下标越界！
```

### （6）数组初始化

静态初始化：

```cpp
int nums[10] = {0};		//数组元素全部为0
int array[10] = {1, 2, 3} 	//数组前三个元素为1，2，3，其他元素为0
int nums[5]{0, 1, 2, 3, 4};	//Cpp11 初始化列表
```

动态初始化：

使用循环

```cpp
int nums[10];
for (int i = 0; i < 10; ++i) {
	cin >> nums[i];
}
```

### （7）冒泡排序

相邻元素两两相互比较，按照排序规则交换元素值

```cpp
#include <iostream>
#include <iomanip>
#include <time.h>

using namespace std;

int main()
{
	int nums[10] = { 0 };
	srand(time(0));
    //随机产生10个数
	for (int i = 0; i < 10; ++i) {
		nums[i] = rand();
	}
	//循环9次，使得有序区覆盖到全部元素
	for (int i = 0; i < 9; ++i) {
		//交换相邻元素，使得最后一个数永远是最大的，维护右大值有序区
		for (int j = 0; j < (10 - i - 1); ++j) {
			if (nums[j] > nums[j + 1]) {
				int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
			}
		}
	}
	for (int i = 0; i < 10; ++i) {
		cout << nums[i] << " ";	
	}
}
```

## 作业

### （1）选择排序

```cpp
#include <iostream>
#include <iomanip>
#include <time.h>

using namespace std;

int main()
{
	int nums[10];
	srand(time(0));
	//产生10个随机数
	for (int i = 0; i < 10; ++i) {
		nums[i] = rand();
	}

	for (int i = 0; i < 9; ++i) {
		int minMark = i;	//最小数标记
		for (int j = i + 1; j < 10; ++j) {
			//选择最小下标
			if (nums[j] < nums[minMark]) {
				minMark = j;
			}
		}
		//交换
        if (i != minMark) {
            int temp = nums[i];
			nums[i] = nums[minMark];
			nums[minMark] = temp;
        }
	}

	//输出
	for (int i = 0; i < 10; ++i) {
		cout << nums[i] << " ";
	}
	return 0;
}
```

### （2）插入排序

```cpp
#include <iostream>
#include <iomanip>
#include <time.h>

using namespace std;

int main()
{
	int nums[10];
	srand(time(0));
	//产生10个随机数
	for (int i = 0; i < 10; ++i) {
		nums[i] = rand();
	}

	for (int i = 1; i < 10; ++i) {
		int key = nums[i];	//记录需要插入元素
		int j = i - 1;
        //查找插入位置，后移元素
		while(j >= 0 && (key < nums[j])) {
			nums[j + 1] = nums[j];
			--j;
		}
		nums[j + 1] = key;	//插入
	}

	//输出
	for (int i = 0; i < 10; ++i) {
		cout << nums[i] << " ";
	}
	return 0;
}
```

# 第九天（2022年7月1日）

做题

# 第十-十一天（2022年7月2 - 3日）

周末

# 第十二天（2022年7月4日，第三周）

## 1.字符串数组

字符数组：用字符串初始化（利用字符数组模拟字符串这种数据类型）

```cpp
//定义一个大小为5的char数组，并用字符串初始化（把字符串中每一个字符拷贝给数组元素）
char buf[5] = "abcd";
```

数组有自己的内存，字符串有独立的内存

注意：**需要预留一个元素给'\\0'**

### （1）字符串相关函数

注意：**字符串操作函数计算时默认以'\\0'作为字符串结束标记**，操作时默认截断'\\0'后面的数据（'\0'也会拷贝）

1. 输入输出：scanf, printf, gets, puts，cin, cout

   scanf，cin不能接收间隔符

   gets接收间隔符（空格，enter）

2. 操作函数

   1. strcpy

      ```cpp
      char* strcpy( char* dest, const char* src );
      ```

      复制 `src` 所指向的字符串，包含空终止符，到首元素为 `dest` 所指向的字符数组。

      若 `dest` 数组不够大则行为未定义。若字符串重叠则行为未定义。

      ```cpp
      char buf[10] = "abcd \0 bd" ;
      char str[10];
      strcpy(str, buf);
      ```

   2. strcat

      ```cpp
      char *strcat( char *dest, const char *src );
      ```

       `src` 所指向的空终止字节字符串的副本到 `dest` 所指向的空终止字节字符串的结尾。字符 `src[0]` 替换 `dest` 末尾的空终止符。产生的字节字符串是空终止的。

      若目标数组对于 `src` 和 `dest` 的内容以及空终止符不够大，则行为未定义。

      若字符串重叠，则行为未定义。

   3. strcmp

      ```cpp
      int strcmp( const char *lhs, const char *rhs );
      ```

      以字典序比较二个空终止字节字符串。

      结果的符号是被比较的字符串中首对不同字符（都转译成 unsigned char ）的值间的差值符号。

      若 `lhs` 或 `rhs` 不是指向空终止字节字符串的指针，则行为未定义。

   4. strlen

      ```cpp
      std::size_t strlen( const char* str );
      ```

      返回给定字节字符串的长度，即首元素为 `str` 所指向的字符数组直到而不包含首个空字符的字符数。若 `str` 所指向的字符数组中无空字符，则行为未定义。

   5. atoi

      ```cpp
      int atoi( const char *str );
      ```

      转译 `str` 所指向的字节字符串中的整数值。

      舍弃任何空白符，直至找到首个非空白符，然后接收尽可能多的字符以组成合法的整数表示，并转换之为整数值。合法的整数值含下列部分：

      - (可选) 正或负号
      - 数位


# 作业

## 1.实现字符串操作函数

### （1）strcpy

```cpp
char* strcpy(char* dest, const char* src) {
	int indexOfSrc = 0;
	int lenOfDest = strlen(dest);
	int lenOfSrc = strlen(src);
	for (int i = 0; i < lenOfDest; ++i) {
		if (indexOfSrc <= lenOfSrc) {
			dest[i] = src[indexOfSrc];
			++indexOfSrc;
		}
		else {
			break;
		}
	}
	return dest;
}
```

### （2）strcat

```cpp
char *strcat(char *dest, const char *src) {
	int index = 0;
	while (dest[index] != '\0') {
		++index;
	}
	for (int i = 0; i < strlen(src); ++i) {
		dest[index] = src[i];
		++index;
	}
	return dest;
}
```

### （3）strcmp

```cpp
int strcmp(const char *lhs, const char *rhs) {
	unsigned int indexOfLhs = 0;
	unsigned int indexOfRhs = 0;
	unsigned int lenOfLhs = strlen(lhs);
	unsigned int lenOfRhs = strlen(rhs);
	while (indexOfLhs < lenOfLhs && indexOfRhs < lenOfRhs) {
		if ((lhs[indexOfLhs] - rhs[indexOfRhs]) < 0) {
			return -1;
		}
		if ((lhs[indexOfLhs] - rhs[indexOfRhs]) > 0) {
			return 1;
		}
		++indexOfLhs;
		++indexOfRhs;
	}
	if (lenOfLhs < lenOfRhs) {
		return -1;
	}
	else if (lenOfLhs > lenOfRhs) {
		return 1;
	}
	else {
		return 0;
	}	
}
```

### （4）strlen

```cpp
size_t strlen(const char* str) {
	int index = 0;
	while (str[index] != '\0') {
		++index;
	}
	return index;
}
```

### （5）atoi

```cpp
int atoi(const char *str) {
	int index = 0;
	int ret = 0;
	int len = strlen(str);
	while (str[index] == ' ' || str[index] == '\n' ||
		str[index] == '\t' && index < len) {
		++index;
	}
	int signMark = 1;
	if (index < len && str[index] == '-') {
		signMark = -1;
		++index;
	}
	else if (index < len && str[index] == '+') {
		signMark = 1;
		++index;
	}
	while (index < len && str[index] >= '0' && str[index] <= '9') {
		ret = ret * 10 + str[index] - '0';
		++index;
	}
	return ret * signMark;
}
```

# 第十三天（2022年7月5日）

## 1.洗牌算法

> [三种洗牌算法shuffle_lyz_cs的博客-CSDN博客_洗牌算法](https://blog.csdn.net/qq_26399665/article/details/79831490)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<time.h>

using namespace std;

//5、	实现随机打乱⼤⼩为5的数组，要求所有元素不能出现在原位上。
int main() {
	int nums[5];
	srand(time(0));
	for (int i = 0; i < 5; ++i) {
		nums[i] = rand();
	}

	cout << "原数组：";
	for (int i = 0; i < 5; ++i) {
		cout << nums[i] << " ";
	}
	cout << '\n';

	for (int i = 0; i < 4; ++i) {
		int j = rand() % (4 - i) + i + 1;
		nums[j] = nums[i] ^ nums[j];
		nums[i] = nums[i] ^ nums[j];
		nums[j] = nums[i] ^ nums[j];
	}

	cout << "打乱顺序后数组：";
	for (int i = 0; i < 5; ++i) {
		cout << nums[i] << " ";
	}
	cout << '\n';
	return 0;
}
```

刘老师算法

打乱顺序，但是可能在原来位置，for循环控制打乱的次数

```cpp
for (int i = 0; i < N; ++i) {
	int row = rand() % 10;
	swap(nums[i % 10], nums[row]);
}
```

## 2. 多维数组

定义：类型 数组名\[维数\]\[维数\]...\[维数\]

### 内存

所有元素内存大小之和，连续内存（按行存储）

```cpp
//定义一个3行4列的二维数组
int nums[3][4];
```

### 求二维数组大小

```cpp
//定义一个3行4列的二维数组
int nums[3][4];
cout << sizeof(nums) << endl;
/*
	output
	48
*/
```

### 访问

数组名\[下标\]\[下标\]

```cpp
cout << nums[0][3] << endl;
```

### n-1维数组

一个多维数组可以看成多个n-1维数组组成（从左往右看）

n为多维数组名，n[i]看成n - 1维数组名

```cpp
//定义一个3行4列的二维数组
int nums[3][4];
cout << sizeof(nums[0]) << endl;
/*
	output
	16
*/
```

多维数组实例

```cpp
int nums[3][4][5];	//三维数组
cout << sizeof(nums) << endl;	//三维数组名
cout << sizeof(nums[0]) << endl;	//二维数组名
cout << sizeof(nums[0][1]) << endl;	//一维数组名
/*
	output
	240
	80
	20
*/
```

### 多维数组地址

```cpp
//定义一个3行4列的二维数组
int nums[3][4];

//整个二维数组的首地址
cout <<	 &nums << endl;	

//整个一维数组的首地址（16个字节的首地址）
cout << nums << endl;	//二维数组名，等价于&nums[0]

cout << &nums[0] << endl;	//一维数组第一个元素的首地址（4个字节的首地址）

cout << nums[0] << endl;	//一维数组名，等价于&n[0][0]

cout << &nums[0][0] << endl;	//

/*
	output
	012FF894
	012FF894
	012FF894
	012FF894
	012FF894
*/
```

## 作业

### 1.猜数字

（1）随机产生0-9无重复的四个数保存到数组中；

（2）从键盘中输入0-9五重复的四个数（1~5次机会）；

（3）比较随机四个数和输入四个数，输出结果

例如：

随机数：1 7 2 4

输入数：1 7 4 5

输出：2A 1B

A表示位置数字都对，B表示数字对位置不对

```cpp
#include <iostream>
#include <time.h>
#include <string>
#include <algorithm>

using namespace std;

//猜数字

void printRule() {
	system("cls");
	cout << "*******************************" << endl;
	cout << "*                             *" << endl;
	cout << "*          猜数字游戏         *" << endl;
	cout << "*                             *" << endl;
	cout << "*******************************" << endl;
	cout << "*     电脑将产生4个随机数字   *" << endl;
	cout << "*     玩家也可以输入4个数字   *" << endl;
	cout << "*     对着四个数字进行猜测    *" << endl;
	cout << "*     输入结束后展示猜测结果  *" << endl;
	cout << "*                             *" << endl;
	cout << "*******************************" << endl;
	system("pause");
}

void printMain() {
	system("cls");
	cout << "*******************************" << endl;
	cout << "*                             *" << endl;
	cout << "*          猜数字游戏         *" << endl;
	cout << "*                             *" << endl;
	cout << "*******************************" << endl;
	cout << "*                             *" << endl;
	cout << "*         1.查看规则          *" << endl;
	cout << "*         2.开始游戏          *" << endl;
	cout << "*         3.退出游戏          *" << endl;
	cout << "*                             *" << endl;
	cout << "*******************************" << endl;
}

void Gaming() {
	system("cls");
	//（1）随机产生0-9无重复的四个数保存到数组中；
	int nums[10] = {};
	srand(time(0));
	//先存储0~9到数组中
	for (int i = 0; i < 10; ++i) {
		nums[i] = i;
	}

	//打乱顺序
	for (int i = 0; i < 9; ++i) {
		int j = rand() % (9 - i) + i + 1;
		swap(nums[i], nums[j]);
	}

	//（2）从键盘中输入0-9无重复的四个数，记录最后成绩
	int count = 0;
	int bestCorretNum = 0;
	int bestWrongPositionNum = 0;
	while (count < 5) {
		int corretNum = 0;
		int wrongPositionNum = 0;
		int playerInput[4] = { 0 };
		cout << "*    请猜测四个数字,你还有" << 5 - count << "次机会    *" << endl;
		for (int i = 0; i < 4; ++i) {
			cin >> playerInput[i];
		}
		for (int i = 0; i < 4; ++i) {
			for (int j = 0; j < 4; ++j) {
				if (nums[i] == playerInput[i]) {
					if (i == j) {
						++corretNum;
					}
					else {
						++wrongPositionNum;
					}
				}
			}
		}
		bestCorretNum = max(bestCorretNum, corretNum);
		bestWrongPositionNum = max(bestWrongPositionNum, wrongPositionNum);
		++count;
	}
	cout << "电脑产生的随机数字:";
	for (int i = 0; i < 4; ++i) {
		cout << nums[i] << " ";
	}
	cout << endl;
	cout << "你的最好成绩：" << bestCorretNum << "A:" << bestWrongPositionNum << "B" << endl;
	system("pause");
}

void stateError() {
	system("cls");
	cout << "输入错误！按任意键返回主界面" << endl;
	system("pause");
}

int main()
{
	int state = 0;
	while (state != 3) {
		switch (state) {
			case 0: {
				printMain();
				cin >> state;
			} break;
			case 1: {
				printRule();
				state = 0;
			} break;
			case 2: {
				Gaming();
				state = 0;
			}
			case 3: {
				break;
			}
			default: {
				stateError();
				state = 0;
			} break;
		}
	}
	return 0;
}
```

### 2.推箱子

```cpp
#include <iostream>
#include<conio.h> 
#include<windows.h>

using namespace std;

int mapOne[10][10] = {
	{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
	{ 1, 2, 0, 0, 0, 0, 0, 0, 0, 1},
	{ 1, 0, 0, 0, 0, 3, 3, 3, 0, 1},
	{ 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
	{ 1, 1, 1, 1, 1, 0, 0, 0, 0, 1},
	{ 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
	{ 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
	{ 1, 0, 1, 0, 0, 1, 0, 0, 0, 1},
	{ 1, 0, 1, 0, 0, 1, 4, 4, 4, 1},
	{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
};

int PlayerX = 1;
int PlayerY = 1;

void drawMap() {
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			switch (mapOne[i][j])
			{
			case 0:
				cout << "  "; //空白的地方
				break;
			case 1:
				cout << "■"; //墙 
				break;
			case 2:
				cout << "♀"; //人 
				break;
			case 3:
				cout << "☆"; //箱子 
				break;
			case 4:
				cout << "◎"; //终点地方 
				break;
			case 6:
				cout << "♂";//人加终点位置 
				break;
			case 7:
				cout << "★";//箱子加终点位置
				break;
			}
		}
		cout << endl;
	}
}



int main() {
	void drawMap();
	void playerMove();
	bool checkWin();
	void findPlayerPos();
	findPlayerPos();
	while (true) {
		system("cls");
		drawMap();
		if (checkWin()) {
			break;
		}
		playerMove();
		
	}
}

bool checkWin() {
	int count = 0;
	for (int i= 0; i < 10; ++i) {
		for (int j = 0; j < 10; ++j) {
			if (mapOne[i][j] == 3) {	//终点的数量
				++count;
			}
		}
	}
	if (count == 0) {
		cout << "你通关了！" << endl;
		return true;
	}
	else {
		return false;
	}
}

void findPlayerPos() {
	//寻找玩家位置
	for (int i = 0; i < 10; ++i) {
		for (int j = 0; j < 10; ++j) {
			if (mapOne[i][j] == 2 || mapOne[i][j] == 6) {
				PlayerX = i;
				PlayerY = j;
			}
		}
	}
}

void playerMove() {
	char moveCommand = 0;
	moveCommand = _getch();
	int OffSetX = 0;	//x偏移量
	int OffSetY = 0;	//y偏移量
	switch (moveCommand)
	{
	case 's':
	case 'S':
		OffSetX = 1;
		break;
	case 'w':
	case 'W':
		OffSetX = -1;
		break;
	case 'd':
	case 'D':
		OffSetY = 1;
		break;
	case 'a':
	case 'A':
		OffSetY = -1;
		break;
	}

	//判断下一个位置是空地或者成功点:
	if (0 == mapOne[PlayerX + OffSetX][PlayerY + OffSetY] || 4 == mapOne[PlayerX + OffSetX][PlayerY + OffSetY])
	{
		//修改地图数据
		mapOne[PlayerX + OffSetX][PlayerY + OffSetY] += 2;//玩家进来
		mapOne[PlayerX][PlayerY] -= 2;//玩家离开
		//修改玩家的坐标:
		PlayerX += OffSetX;
		PlayerY += OffSetY;
	}		//判断下一个位置是否为箱子或者箱子与成功点重合
	else if (3 == mapOne[PlayerX + OffSetX][PlayerY + OffSetY] || 7 == mapOne[PlayerX + OffSetX][PlayerY + OffSetY])
	{
		//判断箱子的下一个位置是空地或者成功点:
		if (0 == mapOne[PlayerX + OffSetX * 2][PlayerY + OffSetY * 2] || 4 == mapOne[PlayerX + OffSetX * 2][PlayerY + OffSetY * 2])
		{
			//修改地图数据
			mapOne[PlayerX + OffSetX * 2][PlayerY + OffSetY * 2] += 3;//箱子进来
			mapOne[PlayerX + OffSetX][PlayerY + OffSetY] -= 1;//玩家进来,箱子被推走
			mapOne[PlayerX][PlayerY] -= 2;//玩家离开
			//修改玩家的坐标:
			PlayerX += OffSetX, PlayerY += OffSetY;
		}
	}

}
```



# 第十四天（2022年7月6日）

## 1.指针

指针：地址和数据类型

### （1）概念

为了方便访问内存中的内容，系统给每一个内存单元（字节）分配一个编号，该编号称为地址，也就是指针

### （2）定义

语法： 

​	类型 *指针变量名；	//此类型表示指针指向的类型

​	类型 指针变量名		//此类型表示指针变量自己的类型

```cpp
int num = 10;
//定义一个int型的指针变量p
int *p = &num;	//
```

注意：**p的类型是int*，指向的类型是int，p存储的是指向的类型（int）的地址**

### （3）指针变量所占的内存

**四个字节**

### （4）指针运算符

指针运算符：&（取地址符）, *(解析引用符)

语法：

&变量名;

*指针名;

注意：

**\&后面一般是变量，必须保证后面的式子有地址**

**\*后必须是地址，取地址内存中的内容**

**\*读取几个字节，看指针指向的类型**

### （5）内存存储

如未说明，一般低位存在低字节

```cpp
int num = 10;
int* p = &num;
```

指针变量存储的地址：指针变量指向的变量的地址

```cpp
cout << p << endl;
```

指针变量的地址：指针变量自己的地址

```cpp
cout << &p << endl;
```

### （6）访问

访问变量一般直接访问，也可以使用指针（地址）间接访问

```cpp
int num = 10;
int* p = &num;
```

注意：**\*p 等价于 num**

### （7）指针变量赋值方式

1.相同类型变量的地址

相同类型：指针指向的类型

```cpp
int *p = &num;
int num2 = 10;
p = &num2;
```

2.相同类型的指针变量

```cpp
int* p1 = p;
```

## 2.指针问题

1. 指针运算符和指针的偏移
2. 指针分类

## 3.指针偏移

指针加（减）一个整数

p + 1：1表示一个单位，**1个单位占几个字节看指针指向的类型**

**两个地址相减：表示两个地址相差多少个单位**

```cpp
	int nums[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	cout << &nums[10] << endl;									//0075FAF8
	cout << &nums[8] << endl;									//0075FAF0
	cout << &nums[10] - &nums[8] << endl;						//2
	cout << nums[&nums[10] - &nums[8]] << endl;					//3
	cout << nums[(short*)&nums[10] - (short*)&nums[8]] << endl;	//5
	cout << nums[(int)&nums[10] - (int)&nums[8]] << endl;		//9
```

## 4.通过指针遍历数组

```cpp
int nums[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int* p = nums;
```

有以下几种方法

```cpp
for (int i = 0; i < 10;i++)
{
	cout << *(p + i) << endl;
}
```

```
for (int i = 0; i < 10; ++i) {
    cout << nums[i] << endl;
}
```

```cpp
for (int i = 0; i < 10; ++i) {
    cout << *(n + i) << endl;
}
```

```cpp
for (int i = 0; i < 10; ++i) {
    //++优先级大于*
    cout << *p++ << endl;
}
```

注意：**以下代码是错误的，nums为一维数组名，是常量，不可修改**

```cpp
/*
for (int i = 0; i < 10; ++i) {
    cout << *nums++ << endl;	// error
}
*/
```

以下代码只修改了数组第一个元素的值

```cpp
for (int i = 0; i < 10; ++i) {
	cout << (*p)++ << endl;
}
/*
	output
	234567891011
*/
```

## 5.指针与一维数组

```cpp
int nums[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int* p = nums;
```

1. n[i]等价于*(n + i);

## 6.void 类型指针

void* pvoid;

可以**指向任意类型**，但不能读写数据，也不能偏移

要使用它，必须进行**强制转换**

```cpp
int num = 10;
void* p = &x;
cout << *(int*)p << endl;
/*
	output
	10
*/
```

## 7.注意以下几个题目

```cpp
	short* p = nullptr;
	short** pp = nullptr;
	short (*p1)[4] = nullptr;
	short *(*p2)[4] = nullptr;
	cout << p + 1 << endl;	//00000002
	cout << pp + 1 << endl;	//00000004
	cout << p1 + 1 << endl;	//00000008
	cout << p2 + 1 << endl;	//00000010
```

p：是一个指向short型的指针

pp：是一个指向short\*型指针的指针

p1：是一个指向short\[4\]数组的指针

p2：是一个指向short\*\[4\]数组的指针，short\*[4]是一个数组，存储类型为short型的指针

```cpp
	int nums[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	cout << &nums[10] << endl;									//0075FAF8
	cout << &nums[8] << endl;									//0075FAF0
	cout << &nums[10] - &nums[8] << endl;						//2
	cout << nums[&nums[10] - &nums[8]] << endl;					//3
	cout << nums[(short*)&nums[10] - (short*)&nums[8]] << endl;	//5
	cout << nums[(int)&nums[10] - (int)&nums[8]] << endl;		//9
```

```cpp
	short nums[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	short* pnums = &nums[10];
	cout << pnums[-2] << endl;	//9
	int *pn = (int *)&nums[10];
	cout << hex << pn[-2] << endl;	//80007
```



## 作业

### 1.画出内存图，写出结果

```cpp
short n[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int *pn = (int*)n;
cout << hex << *pn << endl;
*pn = 0xab12cd;
cout << n[0] << "," << n[1] << endl;
pn = (int*)&n[8];
cout << *pn << endl;
```

# 第十五天（2022年7月7日）

## 1.指针的分类

### （1）基本数据类型的指针

### （2）数组的指针

即指向数组的指针

定义：类型 (\*指针变量名)\[数组的大小\]\[\]...

```cpp
//数组指针：指向int型大小为4的一维数组
int (*p)[4];
```

p是一个指针，指向一个大小为4的int型数组

### （3）指针的数组

指针的数组

即一个数组，每个元素是指针

```cpp
//指针数组
int* p[4];	//先右结合，int* 为类型
```

p是一个数组，数组的每个元素是一个int型指针

### （4）两个类型的区分

判断依据：看变量名是否被括号隔开

### （5）多级指针

多级指针：指向指针的指针变量（多个\*）

### （6）指针的判断

1. 多级指针还是一级指针？

   是否存在多个\*号，并且没有被隔开

2. 降为一级（去掉\*），再判断是基本数据类型还是数组的指针

   ```cpp
   //一级数组指针，指向int** 型的大小为5的数组;
   int** (*p1)[5];
   ```

3. 指针的数组还是数组的指针

   看变量名和维数是否被()隔开，没有隔开是数组，隔开为指针

```cpp
//
int** (*p[5])[5];
```

### （7）sizeof判断

```cpp
	int** (*p)[5];
	cout << sizeof(p) << endl;		//4
	cout << sizeof(*p) << endl;		//20
	cout << sizeof(**p) << endl;	//4
	cout << sizeof(***p) << endl;	//4	
	cout << sizeof(****p) << endl;	//4
```

**指针加\*号，去级别，数组加*号，去维数**

p：一级的数组的指针，指向int** 型的大小为5的数组；

\*p：指针的数组，int** 型的大小为5的数组；

\*\*p：二级int型指针

\*\*\*p：一级int型指针	

\*\*\*\*p：int型

```cpp
	double** (**pdouble[4][3])[3][4];
	cout << sizeof(pdouble) << endl;			//48
	cout << sizeof(*pdouble) << endl;			//12
	cout << sizeof(**pdouble) << endl;			//4
	cout << sizeof(***pdouble) << endl;			//4
	cout << sizeof(****pdouble) << endl;		//48
	cout << sizeof(*****pdouble) << endl;		//16
	cout << sizeof(******pdouble) << endl;		//4
	cout << sizeof(*******pdouble) << endl;		//4
	cout << sizeof(********pdouble) << endl;	//8
```

pdouble：是一个二维的指针的数组名，数组类型为\*\*，维数为\[3\]\[4\]

\*pdouble：是一个一维的指针的数组名，数组类型为\*，维数为[4\]

\*\*pdouble：是一个二级指针

\*\*\*pdouble：是一个一级指针

\*\*\*\*pdouble：是一个二维数组名

\*\*\*\*\*pdouble：是一个一维数组名

\*\*\*\*\*\*pdouble：是一个二级指针

\*\*\*\*\*\*\*pdouble：是一个一级指针

\*\*\*\*\*\*\*\*pdouble：是一个double变量

## 作业

### 1.说明下面变量的含义，并初始化（不能初始化为空）

```cpp
int (*p)[3];
int* (*p1)[3];
int (*p2[3])[4];
int* (*p3[4])[3];
int** (*p4[3][4])[4][3];
```

```cpp
#include <iostream>
#include <iomanip>
#include <time.h>
#include <cstdio>
using namespace std;

int main() {
	int ary[3] = { 1, 2 ,3 };
	int(*p)[3] = &ary;				//p是一维数组的指针，这个一维数组列数为3，每个元素是int型
									//刘：p是一个数组的指针，指向int型大小为3的数组
	cout << p[0][0] << endl;
	cout << sizeof(p) << endl;

	int a = 10, b = 11, c = 12;
	int* aryOne[3] = { &a, &b, &c };
	int* (*p1)[3] = &aryOne;	//p1是一维数组的指针，这个一维数组列数为3，每个元素是int*型
								//刘：p1是一个数组的指针，指向一个int*的列数为3的数组
	cout << p1[0][0][0] << endl;

	int aryTwo[3][4] = {
		{ 1, 2, 3, 4 },
		{ 5, 6, 7, 8 },
		{ 9, 10, 11, 12 },
	};
	int(*p2[3])[4] = {	//p2是一个列数为3的一维数组，p2数组的每个元素是一个指针，这个指针指向一个列数为4的一维数组，这个数组的元素是int型
						//刘：p2是大小为3的一维数组，数组中每一个元素都是数组的指针，该数组指针指向一个int型大小为4的一维数组
		{ &aryTwo[0] },
		{ &aryTwo[1] },
		{ &aryTwo[2] },
	};
	cout << p2[0][0][0] << endl;

	int* aryThree[3] = { &a, &b, &c };
	int* (*p3[4])[3] = {	//p3是一个列数为4的数组，p3数组的每个元素是一个指针，
							//这个指针指向一个列数为3的一维数组，这个一维数组的每个元素是int*
		&aryThree
	};
	cout << p3[0][0][0][0] << endl;

	int t = 4;
	int* tt = &t;
	int** ttt = &tt;
	int** aryFour[4][3] = {
		{ttt}
	};
	int** (*p4[3][4])[4][3] = {	//p4是一个为3行4列的二维数组，p4的每个元素是一个指针
		{&aryFour}				//这个指针指向一个4行3列的二维数组，这个二维数组的每个元素是int**
	};
	cout << p4[0][0][0][0][0][0][0] << endl;
	return 0;
}
```

### 2.说明含义并初始化

```cpp
int *(**p[5][3])[4];
int **(**p1[3])[4][5];
int* (**p3)[4][3];
```

```cpp
#include <iostream>
#include <iomanip>
#include <time.h>
#include <cstdio>
using namespace std;

int main() {

	//p是一个为5行3列的二维数组，这个二维数组的元素是二级指针，
	//这个二级指针指向一个4列的一维数组的指针，这个一维数组元素的类型是int*
	
	//刘：p是五行三列的二维数组，数组每个元素是二级指针
	//该二级指针指向一个一级的数组指针
	//该数组指针指向一个int*的大小为4的一维数组
	int a = 1, b = 2, c = 3, d = 4;
	int* aryOne[4] = { &a, &b, &c, &d };
	int* (* tempOne)[4] = { &aryOne };
	int* (** p[5][3])[4] = {
		{ &tempOne }
	};
	cout << p[0][0][0][0][0][0] << endl;

	//p1是一个3列的一维数组，p1数组的每个元素是二级指针，
	//每个二级指针指向一个4行5列的二维数组的指针，这个二维数组的元素的类型是int**

	//刘：p1是一个大小为3的一维数组，数组中的每个元素是二级指针
	//该二级指针指向一个一级的数组指针，该数组指针指向一个int**型四行五列的二维数组
	int* pa = &a, *pb = &b, *pc = &c, *pd = &d;
	int** aryTwo[4][5] = { 
		{ &pa, &pb, &pc, &pd }
	};
	int** (* tempTwo)[4][5] = &aryTwo;
	int** (** p1[3])[4][5] = {
		{ &tempTwo }
	};
	cout << p1[0][0][0][0][0][0][0] << endl;

	//p3是一个二级指针，这个二级指针指向一个4行3列的二维数组的指针，这个二维数组的元素的是int*
	int* aryThree[4][3] = {
		{pa, pb, pc}
	};
	int* (* tempThree)[4][3] = &aryThree;
	int* (** p3)[4][3] = &tempThree;
	cout << p3[0][0][0][0][0] << endl;
	return 0;
}
```

# 第十六天（2022年7月8日）

## 1.例题

```cpp
	short *p = nullptr;
	cout << p + 1 << endl;		//0000 0002
	short** pp = nullptr;
	cout << pp + 1 << endl;		//0000 0004
	short* (*ppn)[3] = nullptr;
	cout << ppn + 1 << endl;	//0000 000C
	short(*p1)[3] = nullptr;
	cout << p1 + 1 << endl;		//0000 0006
```

```cpp
	short** (**p2)[3][4] = nullptr;
	cout << p2 + 1 << endl;	//0000 0004

	//一维数组：每个元素都是数组的指针
	short (*p3[3])[4];
	//判断两个地址相差多少个字节
	cout << (int)&p3[1] - (int)&p3[0] << endl;	//4
short*(**p4[3])[4];
	cout << (int)&p4[1] - (int)&p4[0] << endl;			//4
	int m[3][5];
	cout << (int)(&m + 1) - (int)&m << endl;			//60
	cout << (int)(&m[1]) - (int)&m[0] << endl;			//20
	cout << (int)(&m[2][0]) - (int)&m[0][0] << endl;	//40
	short pm[3][4];
	short(*p5[3][5])[4] = { pm, pm + 2, pm + 1 };
	cout << (int)(&p5 + 1) - (int)&p5 << endl;			//60
	cout << (int)&p5[1] - (int)&p5[0] << endl;			//20
	cout << (int)&p5[1][0] - (int)&p5[0][1] << endl;	//16 
	cout << p5[0][1] - p5[0][0] << endl;				//2
	cout << (int)p5[0][1] - (int)p5[0][0] << endl;		//16
```

## 2.指针总结

1. 指针概念

   地址是内存的编号，指针是一种数据类型，指针就是地址

2. 指针定义

   类型\* 指针变量名

3. 指针运算符

   取地址&，解引用*

4. 指针偏移

   加或者减整数，偏移指针所指向的类型的内存单位

5. 指针与一维数组

6. 指针分类

   一级基本数据类型指针，一级数组指针，多级基本数据类型指针，多级数组指针

7. 指针变量本身的类型和其所指向的类型

8. 指针变量指向的类型

   基本数据类型

   数组

   指针

9. 指针的数组

10. 数组的指针

11. 指针变量赋值的方式

    相同类型变量的地址

    相同类型的指针变量

    数组名

## 本周考点

1. 排序算法（选择、插入、冒泡）

   1. 选择排序

      ```cpp
      for(int i = 0; i < 9; ++i) {
          int minMark = i;
          for (int j = i + 1; j < 10; ++j) {
              if (nums[minMark] > nums[j]) {
                  minMark = j;
              }
          }
          if (minMark != i) {
              swap(nums[i], nums[minMark]);
          }
      }
      ```
      
   2. 插入排序

      ```cpp
      for (int i = 1; i < 10; ++i) {
          int temp = nums[i];
          int j = i - 1;
          while(j >= 0 && nums[j] > temp) {
              nums[j + 1] = nums[j];
          }
          nums[j + 1] = temp;
      }
      ```
   
   3. 冒泡排序

      ```cpp
      for (int i = 0; i < 9; ++i) {
          for (int j = 0; j < 10 - i - 1; ++j) {
              if (nums[j] > nums[j + 1]) {
                  swap(nums[j], nums[j + 1]);
              }
          }
      }
      ```
   
2. 位运算

3. 字符串函数

# 第十六天（2022年7月9日）

做题，考试

# 第十七天（2022年7月10日）

周末

# 第十八天（2022年7月11日，第四周）

## 1.试卷复盘

### （1）位运算

```cpp
#include <iostream>
#include <iomanip>
#include <time.h>

using namespace std;

int main()
{
	char a = -0xa5;
    //-0xa5 -165 溢出
    //a = 91
   
    //0101 1011 a 补码
    //1010 0100 ~a 整型提升
    //1111 1101 ~a >> 5
    //510 (int)b 
	cout << (int)a << endl;
	unsigned char b = ~a >> 5;
	cout << (int)b << endl;
	return 0;
}
```

### （2）switch（表达式）

**注意：表达式必须包含整型和枚举类型**

while(表达式)

while中的表达式必须是一个bool值

### （3）低地址存储低内存

## 2.指针与数组

1.n为数组名，等价于&n[0]

2.n[i]等价于*(n + i)

3.&n[i] + j等价于&n[i + j]

```cpp
#include <iostream>
#include <iomanip>
#include <time.h>

using namespace std;

int main()
{

	int n[3][4] = {
		{ 4, 3, 2, 1 },
		{ 5, 6, 7, 8 },
		{ 9, 10, 11, 12 },
	};
	int(*p)[4] = n;
	cout << **p++ << endl;		//4
	cout << p[1][2] << endl;	//11
	cout << p[-1][2] << endl;	//2
	cout << p[1][-2] << endl;	//7
	cout << *p[1] << endl;		//9
	cout << (*p)[1] << endl;	//6

	return 0;
}
```

```cpp
#include <iostream>
#include <iomanip>
#include <time.h>

using namespace std;

int main()
{

	int n[3][4] = {
		{ 4, 3, 2, 1 },
		{ 5, 6, 7, 8 },
		{ 9, 10, 11, 12 },
	};
	int *pn[3] = { n[1], n[2], n[0] };
	int **ppn = pn;
	cout << *++*++ppn << endl;	//10
	cout << ppn[1][0] << endl;	//4
	cout << ppn[0][2] << endl;	//12
	cout << ppn[-1][5] << endl;	//10
	cout << ppn[-1][-1] << endl;//1
	cout << *ppn[1] << endl;	//4
	return 0;
}
```

# 第十九天（2022年7月12日）

## 1.例题

```cpp
#include <iostream>
#include <iomanip>
#include <time.h>

using namespace std;

int main()
{

	int n[4][3] = {
		{ 3, 2, 1 },
		{ 6, 5, 4 },	//7,5,4		//7,5,5
		{ 9, 8, 7 },
		{ 12, 11, 10}
	};
	
	int(*pn)[3] = n;
	//					n[1]+1
	int *p[4] = { n[2], n[1], n[3], n[0] };	
	int **pp = p;	//p[1]
	cout << ++*pn[1] << endl;		//7
	cout << (*++pn)[1] << endl;		//5
	cout << pn[1][4] << endl;		//11
	cout << pn[1][-1] << endl;		//4
	cout << pn[-1][1] << endl;		//2
	cout << ++p[1][2] << endl;		//5
	cout << *(p[1] + 2) << endl;	//5
	cout << *++*++pp << endl;		//5
	cout << pp[1][2] << endl;		//10
	cout << pp[0][0] << endl;		//5
	cout << pp[0][5] << endl;		//12

	return 0;
}
```

## 2.指针赋值方式

1.相同类型变量的地址;
2.相同类型的指针变量;
3.数组名;
4.字符串;
5.函数

## 3.指针与字符串

注意：**char*（char型指针），默认以字符串形式输出**

#### （1）字符串数组初始化

把字符串中每一个字符拷贝给数组的每一个元素

```cpp
	//把字符串中每一个字符拷贝给数组的每一个元素
	char buf[10] = "abcd";//只能初始化
	//buf = "abcd";//编译报错
```

注意：字符串字面值常量只能在初始化时赋值给字符数组，因为数组名为常量，不可变

#### （2）字符型指针

```cpp
char* p = "abcd";
```

#### （3）所占内存

```cpp
	//数组的内存大小
	cout << sizeof(buf) << endl;//10
	cout << sizeof(&buf) << endl;//4
	cout << sizeof(&p) << endl;//4
	cout << sizeof(*p) << endl;//1

	//指针变量的内存大小
	cout << sizeof(p) << endl;//4
```

#### （4）求字符串长度

注意：strlen不包括\'\\0\'

```cpp
	//求字符串的长度(不包括'\0')
	cout << strlen(buf) << endl;//4
	cout << strlen(p) << endl;//4
```

#### （5）相同内容的字符型指针与字符数组不相等

因为字符数组是拷贝，字符型指针是指向

```cpp
	const char buf[5] = "abcd";
	const char* p = "abcd";
	if (buf == p) {
		cout << "yes" << endl;
	}
	else {
		cout << "no" << endl;
	}
/*
output
no
*/
```

#### （6）相同指向的字符型指针相同

因为是相同指向，系统中的字符串只有一份

```cpp
	const char* p1 = "abcd";
	const char* p2 = "abcd";
	if (p1 == p2) {
		cout << "yes" << endl;
	}
	else {
		cout << "no" << endl;
	}
/*
output
yes
*/
```

注意：**如果指向部分不相同，即使开头相同，也不相等**

```cpp
	const char* p1 = "abcd";
	const char* p2 = "abcd\0";
	if (p1 == p2) {
		cout << "yes" << endl;
	}
	else {
		cout << "no" << endl;
	}
/*
output
no
*/
```

#### （7）char型指针（地址）系统默认以字符串形式输出

```cpp
cout << p << endl;	//abcd
```

## 4.例题

```cpp
	char c2[2] = { 'a', 'b' };
	short *pshort = (short*)c2;
	cout <<hex<< *pshort << endl;//6261
	int n = 0x6364;
	char *pn = (char*)&n;
	cout << pn << endl;//dc
```

注意：char*输出到\'\\0\'

```cpp
#include <iostream>
#include <iomanip>
#include <time.h>

using namespace std;

int main()
{
	char* pchar[4] = { "qwert", "asdfg", "zxcvb", "tyzuy" };
	//							pchar + 3
	char **pp[4] = { pchar + 1, pchar + 2, pchar, pchar + 3 };
	char ***ppp = pp;	//pp + 1
	cout << *++*++ppp + 1 << endl;		//yzuy
	cout << ppp[-1][2] << endl;			//tyzuy
	cout << *ppp[2] + 2 << endl;		//zuy
	cout << *(*ppp - 1) + 3 << endl;	//vb

	return 0;
}
```

# 第二十天（2022年7月13日）

## 1.指针与const

const修饰，使得变量为只读

```cpp
const int n = 10;	//必须初始化，初始化后不可修改
```

### （1）const修饰变量不可修改

const修饰变量不可修改，且必须初始化

### （2）指针常量

```cpp
int * const p = nullptr;
```

指针类型的常量，是指指针本身不可变

即不可改变指针的指向，依然可以通过指针改变变量的值

注意：**常量必须初始化**

### （3）常量指针

常量的指针

```
int const * p;
```

指向常量的指针，是指指针指向的变量不可变，为常量，指针本身可变

即可以改变指针的指向，指向的变量不可变

### （3）指针常量和常量指针的区分

通过观察const在\*之前还是在\*后

在前为常量指针，在后为指针常量

### （4）指向常量的指针常量

```cpp
int const * const p = nullptr;
```

此时：指针本身和指针所指向的都不可变

### （5）常量的指针可以指向普通变量

```cpp
int num = 10;
int const * p = &num;
//*p = 100 error
```

## 2.指针与内存

### （1）静态全局区

编译时，系统分配内存并提供**默认值0**，程序结束，系统自动回收内存，

**包含静态变量和全局变量**

静态变量：static修饰的变量

静态局部变量、静态全局变量、静态函数、静态数据成员、静态成员函数

全局变量：定义在函数外的变量

```cpp
//全局变量
int global_item = 0;
//静态全局变量
static int global_static_item = 0;
int main() {
	//静态局部变量
	static int numOne;
	
	//局部变量
	int numTwo;
}
```

### （2）同名变量遵循就近原则

```cpp
int saneName = 100;
int main() {
	int saneName = 0;
 	cout << saneName << endl;
}

/*
output
0
*/
```

**可以使用作用域符指定变量**

```cpp
int saneName = 100;
int main() {
	int saneName = 0;
 	cout << ::saneName << endl;
}

/*
output
100
*/
```

### （3）静态全局变量和普通全局变量

1. 生存周期相同：静态全局区
2. 作用域范围不同：
   1. 文件作用域：静态全局变量
   2. 项目作用域：普通全局变量（需要使用extern扩展）

### （4）静态局部变量和普通局部变量

1. 生存周期不同：
   1. 静态局部变量在静态全局区
   2. 普通局部变量在栈区
2. 作用域范围相同：都是在语句块｛｝内

### （5）使用extern关键字扩展作用域

同一项目下，可以使用extern扩展本文件的普通全局变量的作用域到另外一个文件

```cpp
//fileOne.cpp
int global_num = 10;
```

```cpp
//fileTwo.cpp
extern int global_num;	//extern声明
int main() {
    cout << global_num << endl;
}
```

**注意：使用extern关键字时是声明变量**

### （6）栈区

普通局部变量，函数调用时，分配内存，到函数调用结束，自动回收内存

### （7）堆区

由程序员手动申请，手动释放

申请关键字：malloc，free，new，delete

```cpp
int *p = new int;
```

**注意：p是局部变量，在栈区，p所指向的内存，在堆区**

### （8）常量区

字符串

### （9）内存泄漏

指在堆区手动申请的内存，没有手动释放

**所以申请和释放关键字配对使用是一个好习惯**

### （10）野指针（非法使用内存）

在释放内存之后，由于指针的指向没有改变，我们依然可能可以访问指向的内存，此时，这个指针被称为野指针。这种行为是危险的，可能会有难以预料的后果

**所以，在释放内存后，把指针置空是一个好习惯**

## 3.malloc和new区分

1. malloc是函数，new是运算符
2. new自动调用构造函数，malloc只申请内存
3. malloc和new都是申请一段连续的内存

## 4.free和delete区分

1. free是函数，delete是运算符
2. delete自动调用析构函数，free只释放内存

## 作业

1. 创建动态二维数组

   ```cpp
   #include <iostream>
   
   using namespace std;
   
   
   int main()
   {
   	cout << "请输入需要创建的二维数组的行数：" << endl;
   	unsigned int row = 0;
   	unsigned int col = 0;
   	int colLens[100] = { 0 };
   	cin >> row;
   	int** numsPtr = new int*[row];
   	if (numsPtr == nullptr) {
   		cout << "创建失败！" << endl;
   		return 0;
   	}
   	cout << "请输入" << row << "个需要创建的二维数组的列数：" << endl;
   	unsigned int capacity = 0;
   	for (int i = 0; i < row; ++i) {
   		cin >> colLens[i];
   		numsPtr[i] = new int[colLens[i]];
   		if (numsPtr[i] == nullptr) {
   			cout << "创建失败！" << endl;
   			return 0;
   		}
   		capacity += colLens[i];
   	}
   	cout << "创建成功：" << endl;
   
   	cout << "请输入" << capacity << "个数据：" << endl;
   	for (int i = 0; i < row; ++i) {
   		for (int j = 0; j < colLens[i]; ++j) {
   			cin >> numsPtr[i][j];
   		}
   	}
   
   	cout << "输入成功，输出数组元素：" << endl;
   	for (int i = 0; i < row; ++i) {
   		for (int j = 0; j < colLens[i]; ++j) {
   			cout << numsPtr[i][j] << " ";
   		}
   		cout << endl;
   	}
   
   	//释放
   	for (int i = 0; i < row; ++i) {
   		delete[] numsPtr[i];
   		numsPtr[i] = nullptr;
   	}
   	delete[] numsPtr;
   	numsPtr = nullptr;
   	
   	return 0;
   }
   ```

2. 创建动态一维数组

   1. 可以无限添加元素
   2. 内存扩容：原来的两倍
   3. 删除元素；删除符合条件的元素（1个或多个）
   4. 排序
   5. 删除重复元素

   ```cpp
   #include <iostream>
   
   using namespace std;
   
   
   //扩展容量
   void externCapacity(int* &nums, unsigned int& len, unsigned int& capacity) {
   	int* tempPtr = nums;
   	nums = new int[capacity * 2];
   	for (int i = 0; i < len; ++i) {
   		nums[i] = tempPtr[i];
   	}
   	delete[] tempPtr;
   	tempPtr = nullptr;
   }
   
   //向后插入
   void push(int num, int* &nums, unsigned int& len, unsigned int& capacity) {
   	if (len + 1 >= capacity) {
   		externCapacity(nums, len, capacity);
   	}
   	nums[len] = num;
   	++len;
   }
   
   //移除最后一个元素
   void pop_back(int* &nums, unsigned int& len) {
   	if (len == 0) {
   		return;
   	}
   	--len;
   }
   
   //查找元素
   int search_num(int num, int* &nums, unsigned int& len) {
   	for (int i = 0; i < len; ++i) {
   		if (nums[i] == num) {
   			return i;
   		}
   	}
   	return -1;
   }
   
   //移除指定元素
   void pop_num(int num, int* &nums, unsigned int& len) {
   	int index = search_num(num, nums, len);
   	if (index == -1) {
   		cout << "没有这个元素，删除失败！" << endl;
   		return;
   	}
   
   	for (int i = index; i < len; ++i) {
   		nums[i] = nums[i + 1];
   	}
   	--len;
   	cout << "删除成功" << endl;
   }
   
   void pop_num_index(int index, int* &nums, unsigned int& len) {
   	if (index >= len) {
   		cout << "错误，下标不存在" << endl;
   	}
   	else {
   		for (int i = index; i < len; ++i) {
   			nums[i] = nums[i + 1];
   		}
   		--len;
   		cout << "删除成功" << endl;
   	}
   }
   
   //初始化数组
   void initArray(int* &nums, unsigned int& len, unsigned int& capacity) {
   	nums = new int[len * 2];
   	capacity = len * 2;
   }
   
   void sortArray(bool flag, int* &nums, unsigned int& len) {
   	if (flag) {
   		for (int i = 0; i < len - 1; ++i) {
   			int minMark = i;
   			for (int j = i + 1; j < len; ++j) {
   				if (nums[minMark] > nums[j]) {
   					minMark = j;
   				}
   			}
   			if (minMark != i) {
   				swap(nums[minMark], nums[i]);
   			}
   		}
   	}
   	else {
   		for (int i = 0; i < len - 1; ++i) {
   			int maxMark = i;
   			for (int j = i + 1; j < len; ++j) {
   				if (nums[maxMark] < nums[j]) {
   					maxMark = j;
   				}
   			}
   			if (maxMark != i) {
   				swap(nums[maxMark], nums[i]);
   			}
   
   		}
   	}
   }
   void deleteSameNum(int* &nums, unsigned int& len) {
   	for (int i = 0; i < len; ++i) {
   		for (int j = 0; j < len; ++j) {
   			if (i != j && nums[i] == nums[j]) {
   				swap(nums[j], nums[len - 1]);
   				--len;
   			}
   		}
   	}
   }
   
   void printArray(int* &nums, unsigned int& len) {
   	for (int i = 0; i < len; ++i) {
   		cout << nums[i] << " ";
   	}
   	cout << endl;
   }
   
   void push_back(int num, int* &nums, unsigned int& len, unsigned int& capacity) {
   	if (len + 1 == capacity) {
   		externCapacity(nums, len, capacity);
   	}
   	nums[len] = num;
   	++len;
   }
   
   int main()
   {
   	int* nums = nullptr;
   	unsigned int len = 0;
   	unsigned int capacity = 0;
   	cout << "请输入需要创建的一维数组的元素个数：" << endl;
   	cin >> len;
   	initArray(nums, len, capacity);
   
   	cout << "请输入一维数组的元素：" << endl;
   	for (int i = 0; i < len; ++i) {
   		cin >> nums[i];
   	}
   	if (nums != nullptr) {
   		cout << "创建成功!" << endl;
   		printArray(nums, len);
   	}
   	else {
   		cout << "创建失败！" << endl;
   	}
   
   	bool flag = false;
   	cout << "是否需要增加元素（0或非0）" << endl;
   	cin >> flag;
   	if (flag) {
   		int num = 0;
   		cout << "请输入指定元素：" << endl;
   		cin >> num;
   		push_back(num, nums, len, capacity);
   		printArray(nums, len);
   	}
   
   	cout << "是否需要删除一个指定元素（0或非0）" << endl;
   	cin >> flag;
   	if (flag) {
   		int num = 0;
   		cout << "请输入指定元素：" << endl;
   		cin >> num;
   		pop_num(num, nums, len);
   		printArray(nums, len);
   	}
   
   	cout << "是否需要删除指定下标元素（0或非0）" << endl;
   	cin >> flag;
   	if (flag) {
   		int num = 0;
   		cout << "请输入指定下标：" << endl;
   		cin >> num;
   		pop_num_index(num, nums, len);
   		printArray(nums, len);
   	}
   
   	cout << "是否需要排序（0或非0）" << endl;
   	cin >> flag;
   	if (flag) {
   		cout << "升序或降序（0或非0）：" << endl;
   		cin >> flag;
   		sortArray(flag, nums, len);
   		printArray(nums, len);
   	}
   
   	cout << "是否需要删除重复元素（0或非0）" << endl;
   	cin >> flag;
   	if (flag) {
   		deleteSameNum(nums, len);
   		printArray(nums, len);
   	}
   	return 0;
   }
   ```
   
   

# 第二十一天（2022年7月14日）



# 第二十二天（2022年7月15日）

## 1.引用

定义变量的别名

语法：类型& 引用名 = 变量名;

注意：**引用必须初始化**

```cpp
int num = 10;
int& refNum = num;
cout << refNum << endl;
```

## 2.引用与指针的区别

1. 引用必须初始化，但指针可以不初始化；
2. 指针可以为空，引用不能为空
3. 指针有自己独立的内存空间，引用和被引用的对象共享内存
4. 指针可以修改，引用所引用变量不可修改

## 3.数组的引用

```cpp
int nums[5] = { 0 };
int (&refNums)[5] = nums;
```

## 4.typedef

typedef给类型取别名

语法：typedef 类型名 新类型名

```cpp
//重命名int
typedef int Integer;
//定义一个int型变量
Integer num = 10;

//重命名int型长度为五的数组
typedef int IntegerS[5];
//定义了一个int型，长度为五的数组
Integers nums = { 0 };
```

 

# 第二十三天（2022年7月16日）



# 第二十四天（2022年7月17日）



# 第二十五天（2022年7月18日，第五周）



# 第二十六天（2022年7月19日）



# 第二十七天（2022年7月20日）

## 1.函数

一般用于解决单一问题的方法，

函数声明、定义、调用

## 2.函数分类

库函数和自定义函数

有参函数和无参函数

## 3.函数定义

语法：

返回值类型 函数名(参数类型 变量名)

{

​	函数体

}

## 4.函数调用

只能在函数内调用其他或本身函数

语法：

函数名(实参列表);

## 5.函数调用流程

1. 给形参分配临时内存（栈），形参使用实参的值初始化
2. 进入被调函数的函数体
3. return，通过return带回返回值到主调函数，并回收栈区内存

## 6.函数调用的用法

1. 作为一条独立的语句；
2. 作为表达式的一部分，参与运算的是该函数的返回值
3. 作为另一个函数的实参，参与运算的是该函数的返回值

## 7.函数声明

当函数在生存周期外需要使用时，需要先声明

语法：

函数返回值类型 函数名(参数列表);

注意：**此时参数列表中的参数名可省略**

## 8.参数传递方式

1. 值传递
2. 地址传递
3. 引用传递

注意：**如果想通过参数修改某个变量的值，需要通过地址传递或者引用传递**

## 9.作用域

1. 文件作用域
2. 项目作用域
3. 语句块

# 第二十八天（2022年7月21日）

## 1.数组与参数

数组名：既可以作为形参，也可以作为实参

数组元素：只能是实参

## 2.数组作函数形参

注意：**数组名作为函数形参时，作指针处理**

```cpp
void PrintMap(int n[10]) {
	cout << sizeof(n) << endl;
}
/* 
output
4
*/
```

此时，n为int*

所以在设计函数参数时，可以添加一个参数作为数组长度

```cpp
void PrintArray(int m[][4], int row) {
	cout << sizeof(m) << endl;
	cout << sizeof(*m) << endl;
}
/*
output
4
16
*/
```

此时，m为int (*)[4]

## 3.数组的引用作函数参数

```cpp
void PrintArray(int (&refNums)[4]) {
	cout << sizeof(refNums) << endl;
}
/* 
output
16
*/
```

注意：**此时参数为引用，主调函数调用函数时需类型匹配**

```cpp
int main() {
	int nums[4] = { 0 };
	PrintArray(nums);
}
```

## 4.参数使用const修饰，以防修改

```cpp
void PrintArray(const int nums[4]) {
	
}

void PrintArray(const int (&nums)[4]) {
    
}
```



## 作业

### 1.实现动态二维数组

实现两个函数，申请动态二维数组内存和释放内存函数，函数都没有返回值

### 2.实现动态一维数组

函数实现，无返回值

```cpp
#include <iostream>

using namespace std;


//扩展容量
void externCapacity(int* &nums, unsigned int& len, unsigned int& capacity) {
	int* tempPtr = nums;
	nums = new int[capacity * 2];
	for (int i = 0; i < len; ++i) {
		nums[i] = tempPtr[i];
	}
	delete[] tempPtr;
	tempPtr = nullptr;
}

//向后插入
void push(int num, int* &nums, unsigned int& len, unsigned int& capacity) {
	if (len + 1 >= capacity) {
		externCapacity(nums, len, capacity);
	}
	nums[len] = num;
	++len;
}

//移除最后一个元素
void pop_back(int* &nums, unsigned int& len) {
	if (len == 0) {
		return;
	}
	--len;
}

//查找元素
int search_num(int num, int* &nums, unsigned int& len) {
	for (int i = 0; i < len; ++i) {
		if (nums[i] == num) {
			return i;
		}
	}
	return -1;
}

//移除指定元素
void pop_num(int num, int* &nums, unsigned int& len) {
	int index = search_num(num, nums, len);
	if (index == -1) {
		cout << "没有这个元素，删除失败！" << endl;
		return;
	}

	for (int i = index; i < len; ++i) {
		nums[i] = nums[i + 1];
	}
	--len;
	cout << "删除成功" << endl;
}

void pop_num_index(int index, int* &nums, unsigned int& len) {
	if (index >= len) {
		cout << "错误，下标不存在" << endl;
	}
	else {
		for (int i = index; i < len; ++i) {
			nums[i] = nums[i + 1];
		}
		--len;
		cout << "删除成功" << endl;
	}
}

//初始化数组
void initArray(int* &nums, unsigned int& len, unsigned int& capacity) {
	nums = new int[len * 2];
	capacity = len * 2;
}

void sortArray(bool flag, int* &nums, unsigned int& len) {
	if (flag) {
		for (int i = 0; i < len - 1; ++i) {
			int minMark = i;
			for (int j = i + 1; j < len; ++j) {
				if (nums[minMark] > nums[j]) {
					minMark = j;
				}
			}
			if (minMark != i) {
				swap(nums[minMark], nums[i]);
			}
		}
	}
	else {
		for (int i = 0; i < len - 1; ++i) {
			int maxMark = i;
			for (int j = i + 1; j < len; ++j) {
				if (nums[maxMark] < nums[j]) {
					maxMark = j;
				}
			}
			if (maxMark != i) {
				swap(nums[maxMark], nums[i]);
			}

		}
	}
}
void deleteSameNum(int* &nums, unsigned int& len) {
	for (int i = 0; i < len; ++i) {
		for (int j = 0; j < len; ++j) {
			if (i != j && nums[i] == nums[j]) {
				swap(nums[j], nums[len - 1]);
				--len;
			}
		}
	}
}

void printArray(int* &nums, unsigned int& len) {
	for (int i = 0; i < len; ++i) {
		cout << nums[i] << " ";
	}
	cout << endl;
}

void push_back(int num, int* &nums, unsigned int& len, unsigned int& capacity) {
	if (len + 1 == capacity) {
		externCapacity(nums, len, capacity);
	}
	nums[len] = num;
	++len;
}

int main()
{
	int* nums = nullptr;
	unsigned int len = 0;
	unsigned int capacity = 0;
	cout << "请输入需要创建的一维数组的元素个数：" << endl;
	cin >> len;
	initArray(nums, len, capacity);

	cout << "请输入一维数组的元素：" << endl;
	for (int i = 0; i < len; ++i) {
		cin >> nums[i];
	}
	if (nums != nullptr) {
		cout << "创建成功!" << endl;
		printArray(nums, len);
	}
	else {
		cout << "创建失败！" << endl;
	}

	bool flag = false;
	cout << "是否需要增加元素（0或非0）" << endl;
	cin >> flag;
	if (flag) {
		int num = 0;
		cout << "请输入指定元素：" << endl;
		cin >> num;
		push_back(num, nums, len, capacity);
		printArray(nums, len);
	}

	cout << "是否需要删除一个指定元素（0或非0）" << endl;
	cin >> flag;
	if (flag) {
		int num = 0;
		cout << "请输入指定元素：" << endl;
		cin >> num;
		pop_num(num, nums, len);
		printArray(nums, len);
	}

	cout << "是否需要删除指定下标元素（0或非0）" << endl;
	cin >> flag;
	if (flag) {
		int num = 0;
		cout << "请输入指定下标：" << endl;
		cin >> num;
		pop_num_index(num, nums, len);
		printArray(nums, len);
	}

	cout << "是否需要排序（0或非0）" << endl;
	cin >> flag;
	if (flag) {
		cout << "升序或降序（0或非0）：" << endl;
		cin >> flag;
		sortArray(flag, nums, len);
		printArray(nums, len);
	}

	cout << "是否需要删除重复元素（0或非0）" << endl;
	cin >> flag;
	if (flag) {
		deleteSameNum(nums, len);
		printArray(nums, len);
	}
	return 0;
}
```



# 第二十九天（2022年7月22日）

## 1.参数缺省与初始值

函数形参可以缺省，此时函数形参有初始值，在函数声明时

1. 参数缺省的顺序是从右往左，即当一个参数缺省了，后续参数都必须缺省
2. 参数传递的顺序是从左往右

```cpp
void function(int num, string str = "Abcd") {
	
}
```

## 2.函数重载

函数重载条件：

1. 函数名相同
2. 参数（个数，类型，顺序）不同

注意：返回值和形参名不能作为函数重载条件

## 3.函数重载二义性

当函数重载时，使用不当，容易产生二义性

1. 类型不明确导致的二义性
2. 参数缺省导致的二义性

## 4.指针函数

返回指针的函数

注意：

1. 不能返回栈区的地址，因为函数调用结束，系统自动回收

## 5.返回数组指针的函数

1. 直接返回

   ```cpp
   int (*Test())[4] {
   	static int nums[3][4];
   	return nums;
   }
   ```

2. 使用typedef

   ```cpp
   typedef int (*arrsPtr)[4];
   arrsPtr Test() {
   	static int nums[3][4];
   	return nums;
   }
   ```

## 6.返回引用的函数

注意：

1. 不能返回栈区变量的引用

2. 返回引用的函数可以作左值

   ```cpp
   int& getRefNum() {
   	static int num = 10;
   	return num;
   }
   
   int main() {
   	getRefNum() = 100;
   	cout << getRefNum() << endl;
   	
   	return 0;
   }
   ```

## 7.函数的指针

语法：

返回值类型 (*函数指针名)(参数列表) = 函数名;

```cpp
void Test(int num) {
	cout << "Hi" << endl;
}

int main() {
    int (*testPtr)(int) = Test;
}
```

注意：**函数指针参数列表可以省略参数名，但不可省略类型**

## 8.通过函数指针调用函数

```cpp
testPtr(num);
```

## 9.函数指针作为另一个函数的形参

类似C#中的委托

```cpp
void TestA() {
	cout << "TestA" << endl;
}

typedef void (*pFun)();

void testB(pFun func) {
    cout << "TestB" << endl;
    func();
}

int main() {
    testB(testA);
    return 0;
}
```

# 第三十天（2022年7月23日）

## 1. 函数递归

递归：函数直接或者间接的调用自己；

1. 递归层逻辑
2. 跳出条件

例题：

```cpp
#include <iostream>
#include <iomanip>
#include <time.h>
#include <string.h>

using namespace std;

//求 1 / 2 - 1 / 3 + 1 / 4 + ... + 1 / n
double Solution(int n) {
	if (n == 2) {
		return 1.0 / 2;
	}
	else {
		if (n % 2) {
			return Solution(n - 1) - 1.0 / n;
		}
		else {
			return 1.0 / n + Solution(n - 1);
		}
	}
}

int main() {
	cout << Solution(3) << endl;
	return 0;
}

```

## 2.指针总结

1. 定义指针时，为了防止出错，必须初始化：nullptr
2. 使用指针时，先判断是否为空再使用
3. new和delete，malloc和free成对使用，否则可能造成内存泄漏
4. 释放指针后，指针应该置空，防止产生野指针
5. 指针操作数组时，注意指针偏移时，是否数组越界
6. 不能通过指针去修改常量区的数据（字符串）

## 3.本周考点

1. 指针运算符（\*，\&）
2. 指针偏移
3. 指针与数组
4. 指针与字符串
5. 指针与const
6. 指针与内存
7. 指针与引用

## 作业

### 1.扫雷

1. 布雷

   游戏地图：三种难度：10 * 10，20 * 20，自定义地图和雷的数量

2. 遍历整个地图，计算每一个方块（自己不是雷）周围雷的数量

3. 输入打开方块的行列下标

4. 游戏玩法

   1. 是雷，游戏结束
   2. 不是雷，显示周围8个方块中雷的总数量
   3. 周围没有雷，递归调用8次（注意数组越界，是否访问）



# 第三十一天（2022年7月24日）



# 第三十二天（2022年7月25日，第六周）



# 第三十三天（2022年7月26日）

## 1.结构体

定义：

```cpp
struct 结构体名 {
	类型 成员名;
	类型 成员名;
};
```

声明变量:

```cpp
结构体名 变量名;
```

## 2.结构体所占字节数

结构体所占字节数等于成员所占字节数和

注意：**空结构体所占字节数位1字节**，**用以区分结构体变量**

## 3.内存对齐

自定义类型存在内存对齐

内存对齐：

1. 默认情况下，以成员类型中占字节数最大类型作内存对齐
2. 成员声明顺序决定内存对齐
3. 以空间换取时间（对齐后系统无需查找成员）
4. 按照内存大小顺序声明成员

## 4.联合体（共用体）

关键字：union

声明：

```cpp
union 共用体名 {
	类型 成员名;
};
```

注意：**共用体中成员共享一段内存，所占内存为所占内存最大的成员**

注意：**联合体也存在内存对齐**

## 5.联合体初始化

联合体初始化只能初始化一个成员

```cpp
union myUnion {
    type name;
    ...
}
```

## 6.枚举类型

其内存大小与int型一致，**四字节**

关键字：enum

定义：

```cpp
enum test {
	zero,
	one,
	two
}
```

## 7.枚举类型初始化

**枚举类型初始化，只能初始化枚举元素**

```cpp
enum HeroState {
	Stand = 1,
	Move,
	Jump,
	Attact
}

int main() {
    HeroState sta = Move;
}
```

# 第三十四天（2022年7月27日）



# 第三十五天（2022年7月28日）

## 1.宏定义

又称宏替换

在预处理阶段就执行了替换

```cpp
#define type int;
```

## 2.宏定义函数

```cpp
#define func(x) (x) * (x)
```

## 3.内联函数

使用inline关键字声明此函数为内联函数

注意：**此关键字只是建议，真正编译时，此函数是否为真正的内联函数取决于编译器**

作用：当出现函数调用时，复制代码来替代函数调用。使用空间换取时间

1. 当函数中有复杂语句（循环，递归），不宜使用内联
2. 代码足够简单，并且频繁调用，建议声明为内联

## 4.文件读写

由于效率问题，一般使用C语言的文件读写

### 1.fopen

指定文件和打开方式并打开

```cpp
FILE* pfile = fopen("text.txt", "wb+");
```

### 2.fclose

关闭文件指针

```cpp
fclose(pfile);
```

### 3.fputs

将字符串写入到pfile所指向的文件

```cpp
fputs("some text", pfile);
```

对应fgets

将文件中的字符读取到变量中

### 4.fprintf

格式化写入到文件中

```cpp
fprintf(pfile, "fomat", val, val);
```

对应fscanf

格式化读出到变量中

### 5.fwrite

二进制写文件

```cpp
fwrite(首地址, 类型字节, 数量, pfile);
```

## 作业

1. 角色在地图移动（地图数据保存在文件中，每张地图大小可能不同）
2. 角色战斗、升级、使用物品（3种）
3. 背包、装备栏（武器、盔甲）
4. 角色可以交接任务
5. 任务或背包（可扩展、每个格子中物品数量有上限）

